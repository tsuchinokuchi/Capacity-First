
```dataviewjs
dv.span("**ä»Šæ—¥**: " + moment().format("YYYYå¹´MMæœˆDDæ—¥ï¼ˆdddï¼‰"));
```

```dataviewjs
const refreshKey = "__dashboard_auto_refresh";
const currentDate = moment().format("YYYY-MM-DD");

if (!window[refreshKey]) {
  window[refreshKey] = {
    lastDate: currentDate
  };
  
  setInterval(() => {
    const latestDate = moment().format("YYYY-MM-DD");
    if (window[refreshKey].lastDate !== latestDate) {
      window[refreshKey].lastDate = latestDate;
      app.commands.executeCommandById('dataview:refresh-views');
    }
  }, 60 * 1000); // 1åˆ†ã”ã¨ã«ãƒã‚§ãƒƒã‚¯
}

if (window[refreshKey].lastDate !== currentDate) {
  window[refreshKey].lastDate = currentDate;
  setTimeout(() => app.commands.executeCommandById('dataview:refresh-views'), 100);
}
```

---

## ğŸ’­ ã‚¯ã‚¤ãƒƒã‚¯Thino

```dataviewjs
const today = moment().format("YYYY-MM-DD");
const dailyPath = `092.Daily/${today}`;
const container = dv.container;
const wrapper = container.createDiv({ cls: "thino-container" });
wrapper.style.cssText =
  "display: flex; gap: 10px; align-items: center; margin-bottom: 10px; padding: 15px; background: var(--background-secondary); border-radius: 8px;";

const icon = wrapper.createSpan();
icon.textContent = "ğŸ’­";
icon.style.flexShrink = "0";
icon.style.fontWeight = "bold";

const input = wrapper.createEl("input", { attr: { type: "text", placeholder: "Thinoãƒ¡ãƒ¢ã‚’å…¥åŠ›..." } });
input.style.cssText =
  "flex: 1; padding: 12px 16px; border: 1px solid var(--background-modifier-border); border-radius: 4px; background: var(--background-primary); color: var(--text-normal); font-size: 16px; min-height: 44px;";

const button = wrapper.createEl("button", { text: "è¿½åŠ " });
button.setAttr("type", "button");
button.style.cssText =
  "padding: 12px 20px; background: var(--interactive-accent); color: white; border: none; border-radius: 4px; cursor: pointer; font-weight: 500; font-size: 16px; min-height: 44px; min-width: 80px; touch-action: manipulation; -webkit-tap-highlight-color: transparent;";

const handleSubmit = async () => {
  const memo = input.value.trim();
  if (!memo) {
    new Notice("âš ï¸ ãƒ¡ãƒ¢ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„");
    return;
  }
  try {
    const file = app.vault.getAbstractFileByPath(dailyPath + ".md");
    if (!file) {
      new Notice("âŒ ä»Šæ—¥ã®ãƒ‡ã‚¤ãƒªãƒ¼ãƒãƒ¼ãƒˆãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“");
      return;
    }
    let content = await app.vault.read(file);
    const thinoRegex = /^##\s*Thino[^\n]*\r?\n/m;
    const currentTime = moment().format("HH:mm");
    const newEntry = `- ${currentTime} ${memo}\n`;
    if (thinoRegex.test(content)) {
      content = content.replace(thinoRegex, (m) => `${m}${newEntry}`);
    } else {
      content += `\n## Thino\n${newEntry}`;
    }
    await app.vault.modify(file, content);
    input.value = "";
    new Notice("âœ… Thinoã‚’è¿½åŠ ã—ã¾ã—ãŸ");
  } catch (error) {
    new Notice("âŒ ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ: " + error.message);
    console.error(error);
  }
};

input.addEventListener("keypress", (event) => {
  if (event.key === "Enter") {
    event.preventDefault();
    handleSubmit();
  }
});

button.addEventListener("click", handleSubmit);
button.addEventListener("touchend", (event) => {
  event.preventDefault();
  handleSubmit();
});

dv.paragraph(`ğŸ“ **[[${dailyPath}|ä»Šæ—¥ã®ãƒ‡ã‚¤ãƒªãƒ¼ãƒãƒ¼ãƒˆ]]** ã§Thinoç¢ºèª`);
```

---

ğŸ‘‰ [[03.ãƒ„ã‚§ãƒƒãƒ†ãƒ«ã‚«ã‚¹ãƒ†ãƒ³/030.ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹/ã‚¿ã‚¹ã‚¯ç®¡ç†/é€±å‹¤å‹™ã‚°ãƒªãƒƒãƒ‰|é€±å‹¤å‹™ã‚°ãƒªãƒƒãƒ‰ï¼ˆå‹¤å‹™/ä¼‘ã¿ï¼‰]]

---

## ğŸ“‹ ã‚¿ã‚¹ã‚¯ç®¡ç†

### â° 1é€±é–“ä»¥å†…ã®ç· åˆ‡ã‚¿ã‚¹ã‚¯

```dataviewjs
const today = moment().startOf('day');
const schedulePath = "03.ãƒ„ã‚§ãƒƒãƒ†ãƒ«ã‚«ã‚¹ãƒ†ãƒ³/030.ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹/ã‚¿ã‚¹ã‚¯ç®¡ç†/ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«";
const weekFromNow = moment(today).add(7, 'days');

// ä»Šé€±ã¨æ¥é€±ã®æ—¥ä»˜ç¯„å›²ã§ã‚¿ã‚¹ã‚¯ã‚’åé›†
const upcomingTasks = [];

for (let i = 0; i < 14; i++) {
  const date = moment(today).add(i, 'days');
  const dateStr = date.format("YYYY-MM-DD");
  const dateFile = dv.page(`${schedulePath}/${dateStr}`);
  
  if (dateFile) {
    const tasks = dateFile.file.tasks;
    const tasksWithDeadline = tasks.where(t => {
      const text = t.text;
      // â°ã‚’å«ã‚€ã‚¿ã‚¹ã‚¯ï¼ˆç· åˆ‡æ—¥ãŒã‚ã‚‹ã‚¿ã‚¹ã‚¯ï¼‰
      return text.includes("â°") && !t.completed;
    }).array();
    
    tasksWithDeadline.forEach(task => {
      const deadlineMatch = task.text.match(/â° (\d{4}-\d{2}-\d{2})/);
      if (deadlineMatch) {
        const deadlineDate = moment(deadlineMatch[1]);
        const daysDiff = deadlineDate.diff(today, 'days');
        
        // 1é€±é–“ä»¥å†…ã®ç· åˆ‡ã‚¿ã‚¹ã‚¯ã®ã¿
        if (daysDiff >= 0 && daysDiff <= 7) {
          const timeMatch = task.text.match(/â±ï¸ (\d+)/);
          const duration = timeMatch ? `${timeMatch[1]}åˆ†` : "";
          
          const taskName = task.text
            .replace(/â±ï¸ \d+/, "")
            .replace(/ğŸ“… \d{4}-\d{2}-\d{2}/, "")
            .replace(/â° \d{4}-\d{2}-\d{2}/, "")
            .replace(/#\w+/g, "")
            .replace(/^- \[ \] /, "")
            .replace(/^- \[x\] /, "")
            .trim();
          
          let deadlineLabel = "";
          if (daysDiff < 0) {
            deadlineLabel = `ğŸ”´ç· åˆ‡éã (${deadlineDate.format("MM/DD")})`;
          } else if (daysDiff === 0) {
            deadlineLabel = `ğŸŸ ç· åˆ‡ä»Šæ—¥ (${deadlineDate.format("MM/DD")})`;
          } else if (daysDiff <= 3) {
            deadlineLabel = `ğŸŸ¡ç· åˆ‡${daysDiff}æ—¥å¾Œ (${deadlineDate.format("MM/DD")})`;
          } else {
            deadlineLabel = `â°${deadlineDate.format("MM/DD")}`;
          }
          
          upcomingTasks.push({
            taskName,
            duration,
            deadlineDate: deadlineMatch[1],
            deadlineLabel,
            daysDiff,
            scheduledDate: dateStr,
            scheduledDateLabel: date.format("MM/DD(ddd)")
          });
        }
      }
    });
  }
}

if (upcomingTasks.length === 0) {
  dv.paragraph("_1é€±é–“ä»¥å†…ã®ç· åˆ‡ã‚¿ã‚¹ã‚¯ã¯ã‚ã‚Šã¾ã›ã‚“_");
} else {
  // ç· åˆ‡æ—¥é †ã§ã‚½ãƒ¼ãƒˆï¼ˆç·Šæ€¥åº¦ã®é«˜ã„é †ï¼‰
  upcomingTasks.sort((a, b) => {
    // ã¾ãšç· åˆ‡æ—¥ã§ã‚½ãƒ¼ãƒˆï¼ˆè¿‘ã„é †ï¼‰
    if (a.daysDiff !== b.daysDiff) {
      return a.daysDiff - b.daysDiff;
    }
    // ç· åˆ‡æ—¥ãŒåŒã˜å ´åˆã¯äºˆå®šæ—¥ã§ã‚½ãƒ¼ãƒˆ
    return a.scheduledDate.localeCompare(b.scheduledDate);
  });
  
  // ãƒ†ãƒ¼ãƒ–ãƒ«è¡¨ç¤º
  dv.table(
    ["ç· åˆ‡", "ã‚¿ã‚¹ã‚¯", "æ™‚é–“", "äºˆå®šæ—¥"],
    upcomingTasks.map(task => [
      task.deadlineLabel,
      task.taskName,
      task.duration,
      task.scheduledDateLabel
    ])
  );
  
  // ç·Šæ€¥åº¦ã®é«˜ã„ã‚¿ã‚¹ã‚¯ã‚’å¼·èª¿
  const urgentTasks = upcomingTasks.filter(t => t.daysDiff <= 3 && t.daysDiff >= 0);
  if (urgentTasks.length > 0) {
    dv.paragraph(`\nâš ï¸ **ç·Šæ€¥ï¼ˆ3æ—¥ä»¥å†…ï¼‰**: ${urgentTasks.length}ä»¶`);
  }
}
```

---

### âš ï¸ éå»ã®æœªå®Œäº†ã¾ãŸã¯æ—¥ã«ã¡æœªè¨­å®šã‚¿ã‚¹ã‚¯

```dataviewjs
const today = moment().startOf('day');
const schedulePath = "03.ãƒ„ã‚§ãƒƒãƒ†ãƒ«ã‚«ã‚¹ãƒ†ãƒ³/030.ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹/ã‚¿ã‚¹ã‚¯ç®¡ç†/ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«";
const poolPath = "03.ãƒ„ã‚§ãƒƒãƒ†ãƒ«ã‚«ã‚¹ãƒ†ãƒ³/030.ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹/ã‚¿ã‚¹ã‚¯ç®¡ç†/ã‚¿ã‚¹ã‚¯ãƒ—ãƒ¼ãƒ«/ã‚¿ã‚¹ã‚¯ãƒ—ãƒ¼ãƒ«.md";
const daysToLookBack = 30; // éå»30æ—¥é–“ã‚’ç¢ºèª

// ã‚¿ã‚¹ã‚¯ã‚’åé›†
const pendingTasks = [];

for (let i = 1; i <= daysToLookBack; i++) {
  const date = moment(today).subtract(i, 'days');
  const dateStr = date.format("YYYY-MM-DD");
  const dateFile = dv.page(`${schedulePath}/${dateStr}`);
  
  if (dateFile) {
    const tasks = dateFile.file.tasks;
    const tasksWithTime = tasks.where(t => {
      const text = t.text;
      // â±ï¸ã‚’å«ã‚€æœªå®Œäº†ã‚¿ã‚¹ã‚¯
      return text.includes("â±ï¸") && !t.completed;
    }).array();
    
    tasksWithTime.forEach(task => {
      const timeMatch = task.text.match(/â±ï¸ (\d+)/);
      const duration = timeMatch ? `${timeMatch[1]}åˆ†` : "-";
      
      // ç· åˆ‡æ—¥ã‚’æŠ½å‡º
      const deadlineMatch = task.text.match(/â° (\d{4}-\d{2}-\d{2})/);
      let deadlineInfo = "";
      let isOverdue = false;
      
      if (deadlineMatch) {
        const deadlineDate = moment(deadlineMatch[1]);
        const deadlineDaysDiff = deadlineDate.diff(today, 'days');
        
        if (deadlineDaysDiff < 0) {
          deadlineInfo = ` ğŸ”´ç· åˆ‡${Math.abs(deadlineDaysDiff)}æ—¥è¶…é (${deadlineDate.format("MM/DD")})`;
          isOverdue = true;
        } else if (deadlineDaysDiff === 0) {
          deadlineInfo = ` ğŸŸ ç· åˆ‡ä»Šæ—¥ (${deadlineDate.format("MM/DD")})`;
          isOverdue = true;
        } else {
          deadlineInfo = ` â°ç· åˆ‡ã¾ã§${deadlineDaysDiff}æ—¥ (${deadlineDate.format("MM/DD")})`;
        }
      }
      
      const taskName = task.text
        .replace(/â±ï¸ \d+/, "")
        .replace(/ğŸ“… \d{4}-\d{2}-\d{2}/, "")
        .replace(/â° \d{4}-\d{2}-\d{2}/, "")
        .replace(/#\w+/g, "")
        .replace(/^- \[ \] /, "")
        .replace(/^- \[x\] /, "")
        .trim();
      
      const daysAgo = i;
      pendingTasks.push({
        taskName,
        duration,
        scheduledDate: dateStr,
        scheduledDateLabel: date.format("MM/DD(ddd)"),
        daysAgo,
        daysAgoValue: daysAgo,
        daysAgoLabel: `${daysAgo}æ—¥å‰`,
        deadlineInfo,
        isOverdue,
        deadlineDate: deadlineMatch ? deadlineMatch[1] : null,
        originalTaskText: task.text,
        filePath: dateFile.file.path,
        taskLine: task.text
      });
    });
  }
}

const poolFile = dv.page(poolPath);
if (poolFile) {
  const undatedTasks = poolFile.file.tasks.where(t => t.text.includes("â±ï¸") && !t.completed).array();
  undatedTasks.forEach(task => {
    const timeMatch = task.text.match(/â±ï¸ (\d+)/);
    const duration = timeMatch ? `${timeMatch[1]}åˆ†` : "-";
    
    const deadlineMatch = task.text.match(/â° (\d{4}-\d{2}-\d{2})/);
    let deadlineInfo = "";
    let isOverdue = false;
    
    if (deadlineMatch) {
      const deadlineDate = moment(deadlineMatch[1]);
      const deadlineDaysDiff = deadlineDate.diff(today, 'days');
      
      if (deadlineDaysDiff < 0) {
        deadlineInfo = ` ğŸ”´ç· åˆ‡${Math.abs(deadlineDaysDiff)}æ—¥è¶…é (${deadlineDate.format("MM/DD")})`;
        isOverdue = true;
      } else if (deadlineDaysDiff === 0) {
        deadlineInfo = ` ğŸŸ ç· åˆ‡ä»Šæ—¥ (${deadlineDate.format("MM/DD")})`;
        isOverdue = true;
      } else {
        deadlineInfo = ` â°ç· åˆ‡ã¾ã§${deadlineDaysDiff}æ—¥ (${deadlineDate.format("MM/DD")})`;
      }
    }
    
    const taskName = task.text
      .replace(/â±ï¸ \d+/, "")
      .replace(/ğŸ“… \d{4}-\d{2}-\d{2}/, "")
      .replace(/â° \d{4}-\d{2}-\d{2}/, "")
      .replace(/#\w+/g, "")
      .replace(/^- \[ \] /, "")
      .replace(/^- \[x\] /, "")
      .trim();
    
    pendingTasks.push({
      taskName,
      duration,
      scheduledDate: null,
      scheduledDateLabel: "æœªè¨­å®š",
      daysAgo: null,
      daysAgoValue: Number.MAX_SAFE_INTEGER,
      daysAgoLabel: "æœªè¨­å®š",
      deadlineInfo,
      isOverdue,
      deadlineDate: deadlineMatch ? deadlineMatch[1] : null,
      originalTaskText: task.text,
      filePath: poolFile.file.path,
      taskLine: task.text,
      isUndated: true
    });
  });
}

if (pendingTasks.length === 0) {
  dv.paragraph("_éå»ã®æœªå®Œäº†ã¾ãŸã¯æ—¥ã«ã¡æœªè¨­å®šã®ã‚¿ã‚¹ã‚¯ã¯ã‚ã‚Šã¾ã›ã‚“_");
} else {
  // ç·Šæ€¥åº¦é †ã§ã‚½ãƒ¼ãƒˆï¼ˆç· åˆ‡è¶…éâ†’ç· åˆ‡ä»Šæ—¥â†’ç· åˆ‡è¿‘ã„â†’äºˆå®šæ—¥ãŒå¤ã„é †ï¼‰
  pendingTasks.sort((a, b) => {
    // ç· åˆ‡è¶…éã‚’æœ€å„ªå…ˆ
    if (a.isOverdue && !b.isOverdue) return -1;
    if (!a.isOverdue && b.isOverdue) return 1;
    
    // ä¸¡æ–¹ç· åˆ‡ãŒã‚ã‚‹å ´åˆã¯ç· åˆ‡æ—¥ã§ã‚½ãƒ¼ãƒˆ
    if (a.deadlineDate && b.deadlineDate) {
      return moment(a.deadlineDate).diff(moment(b.deadlineDate));
    }
    if (a.deadlineDate) return -1;
    if (b.deadlineDate) return 1;
    
    // äºˆå®šæ—¥ãŒå¤ã„é †
    if (a.daysAgoValue !== b.daysAgoValue) {
      return a.daysAgoValue - b.daysAgoValue;
    }
    return 0;
  });
  
  // ãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹ä»˜ããƒªã‚¹ãƒˆã¨å®Œäº†ãƒœã‚¿ãƒ³ã‚’ä½œæˆ
  const container = dv.container;
  const taskListContainer = document.createElement('div');
  taskListContainer.style.marginBottom = '15px';
  
  const selectedTasks = new Set();
  
  // å…¨é¸æŠ/å…¨è§£é™¤ãƒœã‚¿ãƒ³
  const selectAllContainer = document.createElement('div');
  selectAllContainer.style.marginBottom = '10px';
  selectAllContainer.style.display = 'flex';
  selectAllContainer.style.gap = '10px';
  selectAllContainer.style.flexWrap = 'wrap';
  
  const selectAllButton = document.createElement('button');
  selectAllButton.textContent = 'ğŸ“‹ å…¨ã¦é¸æŠ';
  selectAllButton.style.padding = '6px 12px';
  selectAllButton.style.cursor = 'pointer';
  selectAllButton.style.fontSize = '14px';
  selectAllButton.onclick = () => {
    pendingTasks.forEach((_, index) => {
      const checkbox = document.getElementById(`pending-task-${index}`);
      if (checkbox) {
        checkbox.checked = true;
        selectedTasks.add(index);
      }
    });
    updateCompleteButton();
  };
  
  const deselectAllButton = document.createElement('button');
  deselectAllButton.textContent = 'ğŸ“‹ å…¨ã¦è§£é™¤';
  deselectAllButton.style.padding = '6px 12px';
  deselectAllButton.style.cursor = 'pointer';
  deselectAllButton.style.fontSize = '14px';
  deselectAllButton.onclick = () => {
    pendingTasks.forEach((_, index) => {
      const checkbox = document.getElementById(`pending-task-${index}`);
      if (checkbox) {
        checkbox.checked = false;
        selectedTasks.delete(index);
      }
    });
    updateCompleteButton();
  };
  
  selectAllContainer.appendChild(selectAllButton);
  selectAllContainer.appendChild(deselectAllButton);
  taskListContainer.appendChild(selectAllContainer);
  
  // æ“ä½œãƒœã‚¿ãƒ³ã‚³ãƒ³ãƒ†ãƒŠ
  const actionButtonContainer = document.createElement('div');
  actionButtonContainer.style.marginBottom = '15px';
  actionButtonContainer.style.display = 'flex';
  actionButtonContainer.style.gap = '10px';
  actionButtonContainer.style.flexWrap = 'wrap';
  
  // å®Œäº†ãƒœã‚¿ãƒ³
  const completeButton = document.createElement('button');
  completeButton.textContent = 'âœ… é¸æŠã—ãŸã‚¿ã‚¹ã‚¯ã‚’å®Œäº†';
  completeButton.style.padding = '8px 16px';
  completeButton.style.cursor = 'pointer';
  completeButton.style.flex = '1';
  completeButton.disabled = true;
  completeButton.style.opacity = '0.5';
  
  // å‰Šé™¤ãƒœã‚¿ãƒ³
  const deleteButton = document.createElement('button');
  deleteButton.textContent = 'ğŸ—‘ï¸ é¸æŠã—ãŸã‚¿ã‚¹ã‚¯ã‚’å‰Šé™¤';
  deleteButton.style.padding = '8px 16px';
  deleteButton.style.cursor = 'pointer';
  deleteButton.style.flex = '1';
  deleteButton.disabled = true;
  deleteButton.style.opacity = '0.5';
  
  // æ—¥ã«ã¡æœªè¨­å®šãƒªã‚¹ãƒˆã«ç§»å‹•ãƒœã‚¿ãƒ³
  const poolButton = document.createElement('button');
  poolButton.textContent = 'ğŸ—‚ï¸ é¸æŠã—ãŸã‚¿ã‚¹ã‚¯ã‚’æ—¥ã«ã¡æœªè¨­å®šãƒªã‚¹ãƒˆã¸ç§»å‹•';
  poolButton.style.padding = '8px 16px';
  poolButton.style.cursor = 'pointer';
  poolButton.style.flex = '1';
  poolButton.disabled = true;
  poolButton.style.opacity = '0.5';
  
  // æ—¥ä»˜å¤‰æ›´ãƒœã‚¿ãƒ³
  const changeDateButton = document.createElement('button');
  changeDateButton.textContent = 'ğŸ“… é¸æŠã—ãŸã‚¿ã‚¹ã‚¯ã‚’æ—¥ä»˜ç§»å‹•';
  changeDateButton.style.padding = '8px 16px';
  changeDateButton.style.cursor = 'pointer';
  changeDateButton.style.flex = '1';
  changeDateButton.disabled = true;
  changeDateButton.style.opacity = '0.5';
  
  completeButton.onclick = async () => {
    if (selectedTasks.size === 0) {
      new Notice('ã‚¿ã‚¹ã‚¯ã‚’é¸æŠã—ã¦ãã ã•ã„');
      return;
    }
    
    const selectedIndices = Array.from(selectedTasks).sort((a, b) => b - a);
    let successCount = 0;
    let failCount = 0;
    
    // ãƒ•ã‚¡ã‚¤ãƒ«ã”ã¨ã«ã‚°ãƒ«ãƒ¼ãƒ—åŒ–
    const tasksByFile = {};
    selectedIndices.forEach(index => {
      const task = pendingTasks[index];
      if (!tasksByFile[task.filePath]) {
        tasksByFile[task.filePath] = [];
      }
      tasksByFile[task.filePath].push(task);
    });
    
    // å„ãƒ•ã‚¡ã‚¤ãƒ«ã‚’å‡¦ç†
    for (const [filePath, tasks] of Object.entries(tasksByFile)) {
      try {
        const file = app.vault.getAbstractFileByPath(filePath);
        if (!file) {
          failCount += tasks.length;
          continue;
        }
        
        let content = await app.vault.read(file);
        let modified = false;
        
        // ã‚ˆã‚Šç¢ºå®Ÿãªç½®æ›ã®ãŸã‚ã€è¡Œã”ã¨ã«å‡¦ç†
        const lines = content.split('\n');
        
        for (const task of tasks) {
          // å…ƒã®ã‚¿ã‚¹ã‚¯è¡Œã‚’å®Œäº†ã«å¤‰æ›´
          const originalLine = task.originalTaskText;
          const trimmedOriginal = originalLine.trim();
          
          // ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã‚’æŠ½å‡º
          const projectMatch = trimmedOriginal.match(/ğŸ”—\s*([^\s]+)/);
          const projectName = projectMatch ? projectMatch[1] : null;
          
          // ã‚¿ã‚¹ã‚¯åã‚’æŠ½å‡º
          const taskNameOnly = trimmedOriginal
            .replace(/^- \[[ x]\]\s*/, '')
            .replace(/\s*â±ï¸\s*\d+/, '')
            .replace(/\s*ğŸ“…\s*\d{4}-\d{2}-\d{2}/, '')
            .replace(/\s*â°\s*\d{4}-\d{2}-\d{2}/, '')
            .replace(/\s*ğŸ”—\s*[^\s]+/, '')
            .replace(/\s*#\w+/g, '')
            .trim();
          
          let found = false;
          
          // ã¾ãšå®Œå…¨ä¸€è‡´ã‚’è©¦ã™
          for (let i = 0; i < lines.length; i++) {
            const line = lines[i];
            const trimmedLine = line.trim();
            
            // å®Œå…¨ä¸€è‡´ã¾ãŸã¯è¡ŒãŒå«ã¾ã‚Œã¦ã„ã‚‹å ´åˆ
            if (trimmedLine === trimmedOriginal || trimmedLine.includes(trimmedOriginal) || trimmedOriginal.includes(trimmedLine)) {
              // [ ] ã‚’ [x] ã«å¤‰æ›´
              if (line.includes('- [ ]')) {
                lines[i] = line.replace(/- \[ \]/, '- [x]');
                found = true;
                modified = true;
                successCount++;
                break;
              }
            }
          }
          
          // å®Œå…¨ä¸€è‡´ãŒè¦‹ã¤ã‹ã‚‰ãªã„å ´åˆã¯ã€ã‚¿ã‚¹ã‚¯åã¨ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã§æ¤œç´¢
          if (!found) {
            for (let i = 0; i < lines.length; i++) {
              const line = lines[i];
              const trimmedLine = line.trim();
              
              // ã‚¿ã‚¹ã‚¯è¡Œã‹ã©ã†ã‹ã‚’ç¢ºèª
              const isTaskLine = line.includes('- [') || (taskNameOnly && trimmedLine.includes(taskNameOnly));
              if (!isTaskLine) continue;
              
              // ã‚¿ã‚¹ã‚¯åã‚’å«ã¿ã€æœªå®Œäº†ã§ã€â±ï¸ã‚’å«ã‚€è¡Œã‚’æ¢ã™
              if (line.includes('- [ ]') && taskNameOnly && trimmedLine.includes(taskNameOnly) && line.includes('â±ï¸')) {
                // ã‚¿ã‚¹ã‚¯åãŒä¸€è‡´ã™ã‚‹ã‹ç¢ºèª
                const lineTaskName = trimmedLine
                  .replace(/^- \[[ x]\]\s*/, '')
                  .replace(/\s*â±ï¸\s*\d+/, '')
                  .replace(/\s*ğŸ“…\s*\d{4}-\d{2}-\d{2}/, '')
                  .replace(/\s*â°\s*\d{4}-\d{2}-\d{2}/, '')
                  .replace(/\s*ğŸ”—\s*[^\s]+/, '')
                  .replace(/\s*#\w+/g, '')
                  .trim();
                
                if (lineTaskName === taskNameOnly) {
                  lines[i] = line.replace(/- \[ \]/, '- [x]');
                  found = true;
                  modified = true;
                  successCount++;
                  break;
                }
              }
            }
          }
          
          // ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ã‚‚æ›´æ–°
          if (found && projectName) {
            const projectPath = `03.ãƒ„ã‚§ãƒƒãƒ†ãƒ«ã‚«ã‚¹ãƒ†ãƒ³/030.ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹/ã‚¿ã‚¹ã‚¯ç®¡ç†/ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆ/${projectName}.md`;
            const projectFile = app.vault.getAbstractFileByPath(projectPath);
            if (projectFile) {
              try {
                let projectContent = await app.vault.read(projectFile);
                const projectLines = projectContent.split('\n');
                let projectModified = false;
                
                for (let i = 0; i < projectLines.length; i++) {
                  const line = projectLines[i];
                  const trimmedLine = line.trim();
                  
                  const isTaskLine = line.includes('- [') || (taskNameOnly && trimmedLine.includes(taskNameOnly));
                  if (!isTaskLine) continue;
                  
                  if (taskNameOnly && trimmedLine.includes(taskNameOnly)) {
                    const lineTaskName = trimmedLine
                      .replace(/^- \[[ x]\]\s*/, '')
                      .replace(/\s*â±ï¸\s*\d+/, '')
                      .replace(/\s*ğŸ“…\s*\d{4}-\d{2}-\d{2}/, '')
                      .replace(/\s*â°\s*\d{4}-\d{2}-\d{2}/, '')
                      .replace(/\s*ğŸ”—\s*[^\s]+/, '')
                      .replace(/\s*#\w+/g, '')
                      .trim();
                    
                    if (lineTaskName === taskNameOnly && line.includes('- [ ]')) {
                      projectLines[i] = line.replace(/- \[ \]/, '- [x]');
                      projectModified = true;
                    }
                  }
                }
                
                if (projectModified) {
                  projectContent = projectLines.join('\n');
                  await app.vault.modify(projectFile, projectContent);
                }
              } catch (error) {
                console.error(`ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãƒ•ã‚¡ã‚¤ãƒ« ${projectPath} ã®å‡¦ç†ã‚¨ãƒ©ãƒ¼:`, error);
              }
            }
          }
          
          if (!found) {
            failCount++;
          }
        }
        
        if (modified) {
          content = lines.join('\n');
          await app.vault.modify(file, content);
        }
      } catch (error) {
        console.error(`ãƒ•ã‚¡ã‚¤ãƒ« ${filePath} ã®å‡¦ç†ã‚¨ãƒ©ãƒ¼:`, error);
        failCount += tasks.length;
      }
    }
    
    // çµæœã‚’é€šçŸ¥
    if (successCount > 0) {
      new Notice(`âœ… ${successCount}ä»¶ã®ã‚¿ã‚¹ã‚¯ã‚’å®Œäº†ã—ã¾ã—ãŸ`, 3000);
      if (failCount > 0) {
        new Notice(`âš ï¸ ${failCount}ä»¶ã®å‡¦ç†ã«å¤±æ•—ã—ã¾ã—ãŸ`, 3000);
      }
      // ãƒ“ãƒ¥ãƒ¼ã‚’æ›´æ–°
      setTimeout(() => {
        app.commands.executeCommandById('dataview:refresh-views');
      }, 500);
    } else {
      new Notice('âŒ ã‚¿ã‚¹ã‚¯ã®å®Œäº†ã«å¤±æ•—ã—ã¾ã—ãŸ');
    }
  };
  
  deleteButton.onclick = async () => {
    if (selectedTasks.size === 0) {
      new Notice('âš ï¸ ã‚¿ã‚¹ã‚¯ã‚’é¸æŠã—ã¦ãã ã•ã„');
      return;
    }
    
    try {
      const selectedIndices = Array.from(selectedTasks).sort((a, b) => b - a);
      const tasksByFile = {};
      selectedIndices.forEach(index => {
        const task = pendingTasks[index];
        if (!tasksByFile[task.filePath]) {
          tasksByFile[task.filePath] = [];
        }
        tasksByFile[task.filePath].push(task);
      });
      
      let totalSuccess = 0;
      
      for (const [filePath, tasks] of Object.entries(tasksByFile)) {
        try {
          const file = app.vault.getAbstractFileByPath(filePath);
          if (!file) continue;
          
          let content = await app.vault.read(file);
          const lines = content.split('\n');
          const linesToRemove = new Set();
          let modified = false;
          
          for (const task of tasks) {
            const originalLine = task.originalTaskText;
            const trimmedOriginal = originalLine.trim();
            
            // ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã‚’æŠ½å‡º
            const projectMatch = trimmedOriginal.match(/ğŸ”—\s*([^\s]+)/);
            const projectName = projectMatch ? projectMatch[1] : null;
            
            // ã‚¿ã‚¹ã‚¯åã‚’æŠ½å‡º
            const taskNameOnly = trimmedOriginal
              .replace(/^- \[[ x]\]\s*/, '')
              .replace(/\s*â±ï¸\s*\d+/, '')
              .replace(/\s*ğŸ“…\s*\d{4}-\d{2}-\d{2}/, '')
              .replace(/\s*â°\s*\d{4}-\d{2}-\d{2}/, '')
              .replace(/\s*ğŸ”—\s*[^\s]+/, '')
              .replace(/\s*#\w+/g, '')
              .trim();
            
      // å…ƒã®ãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰å‰Šé™¤
            for (let i = 0; i < lines.length; i++) {
              const line = lines[i];
              const trimmedLine = line.trim();
              
              if (trimmedLine === trimmedOriginal) {
                linesToRemove.add(i);
                modified = true;
                totalSuccess++;
                break;
              }
              
              const isTaskLine = line.includes('- [') || (taskNameOnly && trimmedLine.includes(taskNameOnly));
              if (!isTaskLine) continue;
              
              if (taskNameOnly && trimmedLine.includes(taskNameOnly)) {
                const lineTaskName = trimmedLine
                  .replace(/^- \[[ x]\]\s*/, '')
                  .replace(/\s*â±ï¸\s*\d+/, '')
                  .replace(/\s*ğŸ“…\s*\d{4}-\d{2}-\d{2}/, '')
                  .replace(/\s*â°\s*\d{4}-\d{2}-\d{2}/, '')
                  .replace(/\s*ğŸ”—\s*[^\s]+/, '')
                  .replace(/\s*#\w+/g, '')
                  .trim();
                
                if (lineTaskName === taskNameOnly) {
                  linesToRemove.add(i);
                  modified = true;
                  totalSuccess++;
                  break;
                }
              }
            }
            
            // ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰ã‚‚å‰Šé™¤
            if (projectName) {
              const projectPath = `03.ãƒ„ã‚§ãƒƒãƒ†ãƒ«ã‚«ã‚¹ãƒ†ãƒ³/030.ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹/ã‚¿ã‚¹ã‚¯ç®¡ç†/ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆ/${projectName}.md`;
              const projectFile = app.vault.getAbstractFileByPath(projectPath);
              if (projectFile) {
                try {
                  let projectContent = await app.vault.read(projectFile);
                  const projectLines = projectContent.split('\n');
                  const projectLinesToRemove = new Set();
                  let projectModified = false;
                  
                  for (let i = 0; i < projectLines.length; i++) {
                    const line = projectLines[i];
                    const trimmedLine = line.trim();
                    
                    const isTaskLine = line.includes('- [') || (taskNameOnly && trimmedLine.includes(taskNameOnly));
                    if (!isTaskLine) continue;
                    
                    if (taskNameOnly && trimmedLine.includes(taskNameOnly)) {
                      const lineTaskName = trimmedLine
                        .replace(/^- \[[ x]\]\s*/, '')
                        .replace(/\s*â±ï¸\s*\d+/, '')
                        .replace(/\s*ğŸ“…\s*\d{4}-\d{2}-\d{2}/, '')
                        .replace(/\s*â°\s*\d{4}-\d{2}-\d{2}/, '')
                        .replace(/\s*ğŸ”—\s*[^\s]+/, '')
                        .replace(/\s*#\w+/g, '')
                        .trim();
                      
                      if (lineTaskName === taskNameOnly) {
                        projectLinesToRemove.add(i);
                        projectModified = true;
                      }
                    }
                  }
                  
                  if (projectModified) {
                    const sortedIndices = Array.from(projectLinesToRemove).sort((a, b) => b - a);
                    sortedIndices.forEach(index => {
                      projectLines.splice(index, 1);
                    });
                    projectContent = projectLines.join('\n');
                    await app.vault.modify(projectFile, projectContent);
                  }
                } catch (error) {
                  console.error(`ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãƒ•ã‚¡ã‚¤ãƒ« ${projectPath} ã®å‡¦ç†ã‚¨ãƒ©ãƒ¼:`, error);
                }
              }
            }
          }
          
          if (modified) {
            const sortedIndices = Array.from(linesToRemove).sort((a, b) => b - a);
            sortedIndices.forEach(index => {
              lines.splice(index, 1);
            });
            content = lines.join('\n');
            await app.vault.modify(file, content);
          }
        } catch (error) {
          console.error(`ãƒ•ã‚¡ã‚¤ãƒ« ${filePath} ã®å‡¦ç†ã‚¨ãƒ©ãƒ¼:`, error);
        }
      }
      
      if (totalSuccess > 0) {
        new Notice(`ğŸ—‘ï¸ ${totalSuccess}ä»¶ã®ã‚¿ã‚¹ã‚¯ã‚’å‰Šé™¤ã—ã¾ã—ãŸ`);
        setTimeout(() => {
          app.commands.executeCommandById('dataview:refresh-views');
        }, 500);
      } else {
        new Notice('âš ï¸ ã‚¿ã‚¹ã‚¯ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸ');
      }
    } catch (error) {
      console.error('ã‚¿ã‚¹ã‚¯å‰Šé™¤å‡¦ç†ã‚¨ãƒ©ãƒ¼:', error);
      new Notice(`âŒ ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ: ${error.message}`);
    }
  };
  
  poolButton.onclick = async () => {
    if (selectedTasks.size === 0) {
      new Notice('âš ï¸ ã‚¿ã‚¹ã‚¯ã‚’é¸æŠã—ã¦ãã ã•ã„');
      return;
    }
    
    try {
      const poolPath = "03.ãƒ„ã‚§ãƒƒãƒ†ãƒ«ã‚«ã‚¹ãƒ†ãƒ³/030.ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹/ã‚¿ã‚¹ã‚¯ç®¡ç†/ã‚¿ã‚¹ã‚¯ãƒ—ãƒ¼ãƒ«/ã‚¿ã‚¹ã‚¯ãƒ—ãƒ¼ãƒ«.md";
      let poolFile = app.vault.getAbstractFileByPath(poolPath);
      if (!poolFile) {
        poolFile = await app.vault.create(poolPath, `# ğŸ“‹ ã‚¿ã‚¹ã‚¯ãƒ—ãƒ¼ãƒ«ï¼ˆæœªã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚¿ã‚¹ã‚¯ï¼‰\n\n## æœªã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚¿ã‚¹ã‚¯\n\n`);
      }
      
      let poolContent = await app.vault.read(poolFile);
      const selectedIndices = Array.from(selectedTasks).sort((a, b) => b - a);
      const tasksByFile = {};
      selectedIndices.forEach(index => {
        const task = pendingTasks[index];
        if (!tasksByFile[task.filePath]) {
          tasksByFile[task.filePath] = [];
        }
        tasksByFile[task.filePath].push(task);
      });
      
      let totalSuccess = 0;
      
      for (const [filePath, tasks] of Object.entries(tasksByFile)) {
        try {
          const file = app.vault.getAbstractFileByPath(filePath);
          if (!file) continue;
          
          let content = await app.vault.read(file);
          const lines = content.split('\n');
          const linesToRemove = new Set();
          let modified = false;
          
          for (const task of tasks) {
            const originalLine = task.originalTaskText;
            const trimmedOriginal = originalLine.trim();
            
            // å…ƒã®ãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰å‰Šé™¤
            for (let i = 0; i < lines.length; i++) {
              const trimmedLine = lines[i].trim();
              if (trimmedLine === trimmedOriginal || trimmedLine.includes(trimmedOriginal) || trimmedOriginal.includes(trimmedLine)) {
                linesToRemove.add(i);
                modified = true;
                break;
              }
            }
            
            // æ—¥ã«ã¡æœªè¨­å®šãƒªã‚¹ãƒˆã«è¿½åŠ ï¼ˆğŸ“…ã‚’å‰Šé™¤ï¼‰
            const poolTask = originalLine.replace(/\s*ğŸ“…\s*\d{4}-\d{2}-\d{2}/, '').trim();
            poolContent += poolTask + '\n';
            totalSuccess++;
          }
          
          if (modified) {
            const sortedIndices = Array.from(linesToRemove).sort((a, b) => b - a);
            sortedIndices.forEach(index => {
              lines.splice(index, 1);
            });
            content = lines.join('\n');
            await app.vault.modify(file, content);
          }
        } catch (error) {
          console.error(`ãƒ•ã‚¡ã‚¤ãƒ« ${filePath} ã®å‡¦ç†ã‚¨ãƒ©ãƒ¼:`, error);
        }
      }
      
      if (totalSuccess > 0) {
        await app.vault.modify(poolFile, poolContent);
        new Notice(`ğŸ—‚ï¸ ${totalSuccess}ä»¶ã®ã‚¿ã‚¹ã‚¯ã‚’æ—¥ã«ã¡æœªè¨­å®šãƒªã‚¹ãƒˆã¸ç§»å‹•ã—ã¾ã—ãŸ`);
        setTimeout(() => {
          app.commands.executeCommandById('dataview:refresh-views');
        }, 500);
      }
    } catch (error) {
      console.error('æ—¥ã«ã¡æœªè¨­å®šãƒªã‚¹ãƒˆç§»å‹•å‡¦ç†ã‚¨ãƒ©ãƒ¼:', error);
      new Notice(`âŒ ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ: ${error.message}`);
    }
  };
  
  changeDateButton.onclick = async () => {
    if (selectedTasks.size === 0) {
      new Notice('âš ï¸ ã‚¿ã‚¹ã‚¯ã‚’é¸æŠã—ã¦ãã ã•ã„');
      return;
    }
    
    try {
      // QuickAddãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã®ç¢ºèª
      const quickAddPlugin = app.plugins.plugins.quickadd;
      if (!quickAddPlugin || !quickAddPlugin.api) {
        new Notice('âŒ QuickAddãƒ—ãƒ©ã‚°ã‚¤ãƒ³ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
        return;
      }
      const quickAddApi = quickAddPlugin.api;
      
      // æ˜æ—¥ã®æ—¥ä»˜ã‚’ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã¨ã—ã¦è¨­å®š
      const tomorrow = moment().add(1, 'day').format("YYYY-MM-DD");
      
      // ç§»å‹•å…ˆã®æ—¥ä»˜ã‚’å…¥åŠ›
      const newDateInput = await quickAddApi.inputPrompt(
        "ç§»å‹•å…ˆã®æ—¥ä»˜ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ (YYYY-MM-DD) - ç©ºç™½ã®å ´åˆã¯æ˜æ—¥",
        tomorrow
      );
      
      // ã‚­ãƒ£ãƒ³ã‚»ãƒ«ã•ã‚ŒãŸå ´åˆã‚„nullã®å ´åˆã¯å‡¦ç†ã‚’ä¸­æ–­
      if (newDateInput === null || newDateInput === undefined) {
        return;
      }
      
      // ç©ºç™½ã®å ´åˆã¯æ˜æ—¥ã«è¨­å®š
      const inputDate = newDateInput.trim() || tomorrow;
      
      // æ—¥ä»˜ã®å¦¥å½“æ€§ãƒã‚§ãƒƒã‚¯
      const newDate = moment(inputDate, "YYYY-MM-DD");
      if (!newDate.isValid()) {
        new Notice('ç„¡åŠ¹ãªæ—¥ä»˜å½¢å¼ã§ã™ã€‚YYYY-MM-DDå½¢å¼ã§å…¥åŠ›ã—ã¦ãã ã•ã„');
        return;
      }
      
      const newDateStr = newDate.format("YYYY-MM-DD");
      const selectedIndices = Array.from(selectedTasks).sort((a, b) => b - a);
      let totalSuccess = 0;
      
      // ç§»å‹•å…ˆã®ãƒ•ã‚¡ã‚¤ãƒ«ã‚’æº–å‚™
      const newFilePath = `${schedulePath}/${newDateStr}.md`;
      let newFile = app.vault.getAbstractFileByPath(newFilePath);
      if (!newFile) {
        newFile = await app.vault.create(newFilePath, `## ä»Šæ—¥ã®ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«\n\n`);
      }
      let newFileContent = await app.vault.read(newFile);
      
      // ãƒ•ã‚¡ã‚¤ãƒ«ã”ã¨ã«ã‚°ãƒ«ãƒ¼ãƒ—åŒ–
      const tasksByFile = {};
      selectedIndices.forEach(index => {
        const task = pendingTasks[index];
        if (!tasksByFile[task.filePath]) {
          tasksByFile[task.filePath] = [];
        }
        tasksByFile[task.filePath].push(task);
      });
      
      // å„ãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰ã‚¿ã‚¹ã‚¯ã‚’å‰Šé™¤ã—ã€æ–°ã—ã„ãƒ•ã‚¡ã‚¤ãƒ«ã«è¿½åŠ 
      for (const [filePath, tasks] of Object.entries(tasksByFile)) {
        try {
          const file = app.vault.getAbstractFileByPath(filePath);
          if (!file) continue;
          
          let content = await app.vault.read(file);
          const lines = content.split('\n');
          const linesToRemove = new Set();
          let modified = false;
          
          // ã¾ãšã€ã™ã¹ã¦ã®ã‚¿ã‚¹ã‚¯ã‚’æ–°ã—ã„ãƒ•ã‚¡ã‚¤ãƒ«ã«è¿½åŠ 
          for (const task of tasks) {
            const originalLine = task.originalTaskText;
            const trimmedOriginal = originalLine.trim();
            
            // ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã‚’æŠ½å‡º
            const projectMatch = trimmedOriginal.match(/ğŸ”—\s*([^\s]+)/);
            const projectName = projectMatch ? projectMatch[1] : null;
            
            // æ–°ã—ã„æ—¥ä»˜ã§ã‚¿ã‚¹ã‚¯è¡Œã‚’ä½œæˆ
            let updatedTaskLine = originalLine;
            if (updatedTaskLine.includes('ğŸ“…')) {
              updatedTaskLine = updatedTaskLine.replace(/ğŸ“…\s*\d{4}-\d{2}-\d{2}/, `ğŸ“… ${newDateStr}`);
            } else {
              if (updatedTaskLine.includes('â°')) {
                updatedTaskLine = updatedTaskLine.replace(/(â°\s*\d{4}-\d{2}-\d{2})/, `ğŸ“… ${newDateStr} $1`);
              } else if (updatedTaskLine.includes('ğŸ”—')) {
                updatedTaskLine = updatedTaskLine.replace(/(ğŸ”—\s*[^\s]+)/, `ğŸ“… ${newDateStr} $1`);
              } else {
                updatedTaskLine = updatedTaskLine.trim() + ` ğŸ“… ${newDateStr}`;
              }
            }
            
            // æ–°ã—ã„ãƒ•ã‚¡ã‚¤ãƒ«ã«è¿½åŠ 
            const trimmedUpdatedLine = updatedTaskLine.trim();
            if (!newFileContent.includes(trimmedUpdatedLine)) {
              newFileContent += trimmedUpdatedLine + '\n';
              totalSuccess++;
            }
            
            // ã‚¿ã‚¹ã‚¯åã‚’æŠ½å‡º
            const taskNameOnly = trimmedOriginal
              .replace(/^- \[[ x]\]\s*/, '')
              .replace(/\s*â±ï¸\s*\d+/, '')
              .replace(/\s*ğŸ“…\s*\d{4}-\d{2}-\d{2}/, '')
              .replace(/\s*â°\s*\d{4}-\d{2}-\d{2}/, '')
              .replace(/\s*ğŸ”—\s*[^\s]+/, '')
              .replace(/\s*#\w+/g, '')
              .trim();
            
            // å…ƒã®ãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰å‰Šé™¤
            for (let i = 0; i < lines.length; i++) {
              const line = lines[i];
              const trimmedLine = line.trim();
              
              if (trimmedLine === trimmedOriginal) {
                linesToRemove.add(i);
                modified = true;
                break;
              }
              
              const isTaskLine = line.includes('- [') || (taskNameOnly && trimmedLine.includes(taskNameOnly));
              if (!isTaskLine) continue;
              
              if (taskNameOnly && trimmedLine.includes(taskNameOnly)) {
                const lineTaskName = trimmedLine
                  .replace(/^- \[[ x]\]\s*/, '')
                  .replace(/\s*â±ï¸\s*\d+/, '')
                  .replace(/\s*ğŸ“…\s*\d{4}-\d{2}-\d{2}/, '')
                  .replace(/\s*â°\s*\d{4}-\d{2}-\d{2}/, '')
                  .replace(/\s*ğŸ”—\s*[^\s]+/, '')
                  .replace(/\s*#\w+/g, '')
                  .trim();
                
                if (lineTaskName === taskNameOnly) {
                  linesToRemove.add(i);
                  modified = true;
                  break;
                }
              }
            }
            
            // ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ã®æ—¥ä»˜ã‚‚æ›´æ–°
            if (projectName) {
              const projectPath = `03.ãƒ„ã‚§ãƒƒãƒ†ãƒ«ã‚«ã‚¹ãƒ†ãƒ³/030.ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹/ã‚¿ã‚¹ã‚¯ç®¡ç†/ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆ/${projectName}.md`;
              const projectFile = app.vault.getAbstractFileByPath(projectPath);
              if (projectFile) {
                try {
                  let projectContent = await app.vault.read(projectFile);
                  const projectLines = projectContent.split('\n');
                  let projectModified = false;
                  
                  for (let i = 0; i < projectLines.length; i++) {
                    const line = projectLines[i];
                    const trimmedLine = line.trim();
                    
                    const isTaskLine = line.includes('- [') || (taskNameOnly && trimmedLine.includes(taskNameOnly));
                    if (!isTaskLine) continue;
                    
                    if (taskNameOnly && trimmedLine.includes(taskNameOnly)) {
                      const lineTaskName = trimmedLine
                        .replace(/^- \[[ x]\]\s*/, '')
                        .replace(/\s*â±ï¸\s*\d+/, '')
                        .replace(/\s*ğŸ“…\s*\d{4}-\d{2}-\d{2}/, '')
                        .replace(/\s*â°\s*\d{4}-\d{2}-\d{2}/, '')
                        .replace(/\s*ğŸ”—\s*[^\s]+/, '')
                        .replace(/\s*#\w+/g, '')
                        .trim();
                      
                      if (lineTaskName === taskNameOnly) {
                        if (projectLines[i].includes('ğŸ“…')) {
                          projectLines[i] = projectLines[i].replace(/ğŸ“…\s*\d{4}-\d{2}-\d{2}/, `ğŸ“… ${newDateStr}`);
                        } else {
                          projectLines[i] = projectLines[i].trim() + ` ğŸ“… ${newDateStr}`;
                        }
                        projectModified = true;
                      }
                    }
                  }
                  
                  if (projectModified) {
                    projectContent = projectLines.join('\n');
                    await app.vault.modify(projectFile, projectContent);
                  }
                } catch (error) {
                  console.error(`ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãƒ•ã‚¡ã‚¤ãƒ« ${projectPath} ã®å‡¦ç†ã‚¨ãƒ©ãƒ¼:`, error);
                }
              }
            }
          }
          
          // å…ƒã®ãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰å‰Šé™¤
          if (modified) {
            const sortedIndices = Array.from(linesToRemove).sort((a, b) => b - a);
            sortedIndices.forEach(index => {
              lines.splice(index, 1);
            });
            content = lines.join('\n');
            await app.vault.modify(file, content);
          }
        } catch (error) {
          console.error(`ãƒ•ã‚¡ã‚¤ãƒ« ${filePath} ã®å‡¦ç†ã‚¨ãƒ©ãƒ¼:`, error);
        }
      }
      
      // æ–°ã—ã„ãƒ•ã‚¡ã‚¤ãƒ«ã«ä¿å­˜
      if (totalSuccess > 0) {
        await app.vault.modify(newFile, newFileContent);
        new Notice(`ğŸ“… ${totalSuccess}ä»¶ã®ã‚¿ã‚¹ã‚¯ã‚’${newDateStr}ã«ç§»å‹•ã—ã¾ã—ãŸ`);
        setTimeout(() => {
          app.commands.executeCommandById('dataview:refresh-views');
        }, 500);
      } else {
        new Notice('âš ï¸ ç§»å‹•ã§ããŸã‚¿ã‚¹ã‚¯ãŒã‚ã‚Šã¾ã›ã‚“ã§ã—ãŸ');
      }
    } catch (error) {
      console.error('ã‚¿ã‚¹ã‚¯ç§»å‹•å‡¦ç†ã‚¨ãƒ©ãƒ¼:', error);
      new Notice(`âŒ ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ: ${error.message}`);
    }
  };
  
  const updateActionButtons = () => {
    const count = selectedTasks.size;
    if (count > 0) {
      completeButton.disabled = false;
      completeButton.style.opacity = '1';
      deleteButton.disabled = false;
      deleteButton.style.opacity = '1';
      poolButton.disabled = false;
      poolButton.style.opacity = '1';
      changeDateButton.disabled = false;
      changeDateButton.style.opacity = '1';
    } else {
      completeButton.disabled = true;
      completeButton.style.opacity = '0.5';
      deleteButton.disabled = true;
      deleteButton.style.opacity = '0.5';
      poolButton.disabled = true;
      poolButton.style.opacity = '0.5';
      changeDateButton.disabled = true;
      changeDateButton.style.opacity = '0.5';
    }
  };
  
  // updateCompleteButtonã‚’updateActionButtonsã®ã‚¨ã‚¤ãƒªã‚¢ã‚¹ã¨ã—ã¦ä½¿ç”¨
  const updateCompleteButton = updateActionButtons;
  
  actionButtonContainer.appendChild(completeButton);
  actionButtonContainer.appendChild(deleteButton);
  actionButtonContainer.appendChild(poolButton);
  actionButtonContainer.appendChild(changeDateButton);
  taskListContainer.appendChild(actionButtonContainer);
  
  // ã‚¿ã‚¹ã‚¯ãƒªã‚¹ãƒˆã‚’ä½œæˆ
  const table = document.createElement('table');
  table.style.width = '100%';
  table.style.borderCollapse = 'collapse';
  
  // ãƒ˜ãƒƒãƒ€ãƒ¼
  const thead = document.createElement('thead');
  const headerRow = document.createElement('tr');
  ['', 'äºˆå®šæ—¥', 'ã‚¿ã‚¹ã‚¯', 'æ™‚é–“', 'ç· åˆ‡', 'çµŒé/çŠ¶æ…‹'].forEach(header => {
    const th = document.createElement('th');
    th.textContent = header;
    th.style.padding = '8px';
    th.style.textAlign = 'left';
    th.style.borderBottom = '2px solid var(--background-modifier-border)';
    headerRow.appendChild(th);
  });
  thead.appendChild(headerRow);
  table.appendChild(thead);
  
  // ãƒœãƒ‡ã‚£
  const tbody = document.createElement('tbody');
  pendingTasks.forEach((task, index) => {
    const row = document.createElement('tr');
    row.style.borderBottom = '1px solid var(--background-modifier-border)';
    
    // ãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹
    const checkboxCell = document.createElement('td');
    const checkbox = document.createElement('input');
    checkbox.type = 'checkbox';
    checkbox.id = `pending-task-${index}`;
    checkbox.style.cursor = 'pointer';
    checkbox.onchange = () => {
      if (checkbox.checked) {
        selectedTasks.add(index);
      } else {
        selectedTasks.delete(index);
      }
      updateCompleteButton();
    };
    checkboxCell.appendChild(checkbox);
    checkboxCell.style.padding = '8px';
    row.appendChild(checkboxCell);
    
    // äºˆå®šæ—¥
    const dateCell = document.createElement('td');
    dateCell.textContent = task.scheduledDateLabel;
    dateCell.style.padding = '8px';
    row.appendChild(dateCell);
    
    // ã‚¿ã‚¹ã‚¯å
    const taskCell = document.createElement('td');
    taskCell.textContent = task.taskName;
    taskCell.style.padding = '8px';
    row.appendChild(taskCell);
    
    // æ™‚é–“
    const durationCell = document.createElement('td');
    durationCell.textContent = task.duration;
    durationCell.style.padding = '8px';
    row.appendChild(durationCell);
    
    // ç· åˆ‡
    const deadlineCell = document.createElement('td');
    deadlineCell.textContent = task.deadlineInfo || '-';
    deadlineCell.style.padding = '8px';
    row.appendChild(deadlineCell);
    
    // çµŒéæ—¥æ•°
    const daysCell = document.createElement('td');
    daysCell.textContent = task.daysAgoLabel;
    daysCell.style.padding = '8px';
    row.appendChild(daysCell);
    
    tbody.appendChild(row);
  });
  table.appendChild(tbody);
  taskListContainer.appendChild(table);
  
  container.appendChild(taskListContainer);
  
  // ç· åˆ‡è¶…éã‚¿ã‚¹ã‚¯ã®çµ±è¨ˆ
  const overdueDeadlineTasks = pendingTasks.filter(t => t.isOverdue && t.deadlineDate);
  if (overdueDeadlineTasks.length > 0) {
    dv.paragraph(`\nâš ï¸ **ç· åˆ‡è¶…éã‚¿ã‚¹ã‚¯**: ${overdueDeadlineTasks.length}ä»¶`);
  }
  
  dv.paragraph(`\n**åˆè¨ˆ**: ${pendingTasks.length}ä»¶ã®æœªå®Œäº†ã‚¿ã‚¹ã‚¯`);
}
```

---

### ğŸ“‹ ä»Šæ—¥ã®ã‚¿ã‚¹ã‚¯

```dataviewjs
// ãƒœã‚¿ãƒ³ã‚’è¿½åŠ 
const container = dv.container;
const buttonContainer = document.createElement('div');
buttonContainer.style.display = 'flex';
buttonContainer.style.gap = '10px';
buttonContainer.style.marginBottom = '10px';
buttonContainer.style.flexWrap = 'wrap';

// ã‚¿ã‚¹ã‚¯è¿½åŠ ãƒœã‚¿ãƒ³
const addButton = document.createElement('button');
addButton.textContent = 'â• ã‚¿ã‚¹ã‚¯è¿½åŠ ';
addButton.className = 'mod-cta';
addButton.style.padding = '8px 16px';
addButton.style.cursor = 'pointer';
addButton.onclick = async () => {
  try {
    // QuickAddãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã®ç¢ºèª
    const quickAddPlugin = app.plugins.plugins.quickadd;
    if (!quickAddPlugin || !quickAddPlugin.api) {
      new Notice('âŒ QuickAddãƒ—ãƒ©ã‚°ã‚¤ãƒ³ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
      return;
    }
    const quickAddApi = quickAddPlugin.api;
    
    // ã‚¸ãƒ£ãƒ³ãƒ«è¨­å®šã‚’èª­ã¿è¾¼ã‚€
    const genreConfigPath = "03.ãƒ„ã‚§ãƒƒãƒ†ãƒ«ã‚«ã‚¹ãƒ†ãƒ³/030.ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹/ã‚¿ã‚¹ã‚¯ç®¡ç†/ã‚¸ãƒ£ãƒ³ãƒ«è¨­å®š.md";
    let genres = ["ãƒ‡ã‚¹ã‚¯ãƒ¯ãƒ¼ã‚¯", "å£²å ´ä½œæ¥­", "é¡§å®¢å¯¾å¿œ", "å®šå‹ä½œæ¥­", "å­¦ç¿’", "å¥åº·", "è¶£å‘³", "ãã®ä»–ãƒ—ãƒ©ã‚¤ãƒ™ãƒ¼ãƒˆ"];
    try {
      const genreConfigContent = await dv.io.load(genreConfigPath);
      if (genreConfigContent) {
        const genreMatch = genreConfigContent.match(/const TASK_GENRES = \[([\s\S]*?)\];/);
        if (genreMatch) {
          genres = genreMatch[1]
            .split(',')
            .map(g => g.trim().replace(/^["']|["']$/g, ''))
            .filter(g => g);
        }
      }
    } catch (error) {
      console.error("ã‚¸ãƒ£ãƒ³ãƒ«è¨­å®šã®èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼:", error);
    }
    
    // ã‚¿ã‚¹ã‚¯åã‚’å…¥åŠ›
    const taskName = await quickAddApi.inputPrompt("ã‚¿ã‚¹ã‚¯åã‚’å…¥åŠ›ã—ã¦ãã ã•ã„");
    if (!taskName || !taskName.trim()) {
      return;
    }
    
    // ã‚¸ãƒ£ãƒ³ãƒ«ã‚’é¸æŠ
    const selectedGenre = await quickAddApi.suggester(
      genres,
      genres,
      "ã‚¸ãƒ£ãƒ³ãƒ«ã‚’é¸æŠã—ã¦ãã ã•ã„"
    );
    if (!selectedGenre) {
      return;
    }
    
    // æ‰€è¦æ™‚é–“ã‚’å…¥åŠ›
    const duration = await quickAddApi.inputPrompt("æ‰€è¦æ™‚é–“ï¼ˆåˆ†ï¼‰ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„");
    if (!duration || !duration.trim()) {
      return;
    }
    
    // äºˆå®šæ—¥ã‚’å…¥åŠ›ï¼ˆç©ºç™½ãªã‚‰ä»Šæ—¥ï¼‰
    const defaultDate = moment().format("YYYY-MM-DD");
    const scheduledDateInput = await quickAddApi.inputPrompt(
      "äºˆå®šæ—¥ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ (YYYY-MM-DD) - ç©ºç™½ã®å ´åˆã¯ä»Šæ—¥",
      defaultDate
    );
    if (scheduledDateInput === null || scheduledDateInput === undefined) {
      return;
    }
    
    const trimmedScheduledDate = scheduledDateInput.trim();
    let scheduledDate = defaultDate;
    if (trimmedScheduledDate !== "") {
      const scheduledMoment = moment(trimmedScheduledDate, "YYYY-MM-DD", true);
      if (!scheduledMoment.isValid()) {
        new Notice('ç„¡åŠ¹ãªæ—¥ä»˜å½¢å¼ã§ã™ã€‚ã‚¿ã‚¹ã‚¯ã¯è¿½åŠ ã•ã‚Œã¾ã›ã‚“ã§ã—ãŸ');
        return;
      }
      scheduledDate = scheduledMoment.format("YYYY-MM-DD");
    }
    
    // æœŸæ—¥ã‚’å…¥åŠ›ï¼ˆç©ºç™½å¯ï¼‰
    const deadlineInput = await quickAddApi.inputPrompt("æœŸæ—¥ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ (YYYY-MM-DD) - ç©ºç™½ã®å ´åˆã¯æœŸæ—¥ç„¡ã—", "");
    let deadlineStr = "";
    if (deadlineInput && deadlineInput.trim()) {
      const deadlineDate = moment(deadlineInput.trim(), "YYYY-MM-DD");
      if (deadlineDate.isValid()) {
        deadlineStr = ` â° ${deadlineDate.format("YYYY-MM-DD")}`;
      } else {
        new Notice('ç„¡åŠ¹ãªæ—¥ä»˜å½¢å¼ã§ã™ã€‚æœŸæ—¥ã¯è¨­å®šã•ã‚Œã¾ã›ã‚“ã§ã—ãŸ');
      }
    }
    
    // ã‚¿ã‚¹ã‚¯è¡Œã‚’ä½œæˆ
    const taskLine = `- [ ] ${taskName.trim()} #${selectedGenre} â±ï¸ ${duration.trim()} ğŸ“… ${scheduledDate}${deadlineStr}`;
    
    // ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ãƒ•ã‚¡ã‚¤ãƒ«ã«è¿½åŠ 
    const schedulePath = "03.ãƒ„ã‚§ãƒƒãƒ†ãƒ«ã‚«ã‚¹ãƒ†ãƒ³/030.ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹/ã‚¿ã‚¹ã‚¯ç®¡ç†/ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«";
    const scheduleFilePath = `${schedulePath}/${scheduledDate}.md`;
    let scheduleFile = app.vault.getAbstractFileByPath(scheduleFilePath);
    
    if (!scheduleFile) {
      scheduleFile = await app.vault.create(scheduleFilePath, `## ä»Šæ—¥ã®ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«\n\n`);
    }
    
    let scheduleContent = await app.vault.read(scheduleFile);
    
    // ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ãƒ•ã‚¡ã‚¤ãƒ«ã«ã‚¿ã‚¹ã‚¯ã‚’è¿½åŠ 
    if (!scheduleContent.includes(taskLine)) {
      scheduleContent += taskLine + '\n';
      await app.vault.modify(scheduleFile, scheduleContent);
      new Notice(`âœ… ã‚¿ã‚¹ã‚¯ã‚’è¿½åŠ ã—ã¾ã—ãŸ`);
      setTimeout(() => {
        app.commands.executeCommandById('dataview:refresh-views');
      }, 500);
    } else {
      new Notice('âš ï¸ åŒã˜ã‚¿ã‚¹ã‚¯ãŒæ—¢ã«å­˜åœ¨ã—ã¾ã™');
    }
  } catch (error) {
    new Notice('ã‚¨ãƒ©ãƒ¼: ' + error.message);
    console.error(error);
  }
};

// ãƒœã‚¿ãƒ³ã‚’è¿½åŠ 
buttonContainer.appendChild(addButton);
container.appendChild(buttonContainer);

const today = moment().format("YYYY-MM-DD");
const schedulePath = "03.ãƒ„ã‚§ãƒƒãƒ†ãƒ«ã‚«ã‚¹ãƒ†ãƒ³/030.ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹/ã‚¿ã‚¹ã‚¯ç®¡ç†/ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«";
const projectPath = "03.ãƒ„ã‚§ãƒƒãƒ†ãƒ«ã‚«ã‚¹ãƒ†ãƒ³/030.ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹/ã‚¿ã‚¹ã‚¯ç®¡ç†/ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆ";
const CONFIG_PATH = "03.ãƒ„ã‚§ãƒƒãƒ†ãƒ«ã‚«ã‚¹ãƒ†ãƒ³/030.ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹/ã‚¿ã‚¹ã‚¯ç®¡ç†/config/settings.json";
const DEFAULT_MAX_DAILY_MINUTES = 360;
let maxDailyMinutes = DEFAULT_MAX_DAILY_MINUTES;

try {
  const configContent = await dv.io.load(CONFIG_PATH);
  if (configContent) {
    const config = JSON.parse(configContent);
    if (Number.isFinite(config.maxDailyMinutes)) {
      maxDailyMinutes = config.maxDailyMinutes;
    }
  }
} catch (error) {
  console.error("è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ã®èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼:", error);
}
const todayFile = dv.page(`${schedulePath}/${today}`);

// ã‚¿ã‚¹ã‚¯ã‚’åé›†ï¼ˆã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ãƒ•ã‚¡ã‚¤ãƒ« + ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ï¼‰
let allTasksWithFile = [];

// ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰ã‚¿ã‚¹ã‚¯ã‚’å–å¾—
if (todayFile) {
  const scheduleTasks = todayFile.file.tasks;
  scheduleTasks.forEach(task => {
    allTasksWithFile.push({ task: task, file: todayFile.file });
  });
}

// ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰ã‚‚ã‚¿ã‚¹ã‚¯ã‚’å–å¾—ï¼ˆä¸€æ—¦ç„¡åŠ¹åŒ–ï¼‰
// try {
//   const projectFiles = dv.pages(`"${projectPath}"`)
//     .where(p => p.file.name !== "README" && p.file.name !== "ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆ")
//     .array();
//
//   projectFiles.forEach(projectFile => {
//     try {
//       if (projectFile && projectFile.file && projectFile.file.tasks) {
//         const projectTasks = projectFile.file.tasks;
//         projectTasks.forEach(task => {
//           if (task && task.text) {
//             allTasksWithFile.push({ task: task, file: projectFile.file });
//           }
//         });
//       }
//     } catch (error) {
//       console.error(`ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãƒ•ã‚¡ã‚¤ãƒ« ${projectFile?.file?.path} ã®å‡¦ç†ã‚¨ãƒ©ãƒ¼:`, error);
//     }
//   });
// } catch (error) {
//   console.error("ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰ã®ã‚¿ã‚¹ã‚¯å–å¾—ã‚¨ãƒ©ãƒ¼:", error);
// }

// ä»Šæ—¥ã®æ—¥ä»˜ï¼ˆğŸ“…ï¼‰ã‚’å«ã‚€ã‚¿ã‚¹ã‚¯ã®ã¿ã‚’ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°
const tasksWithTimeAndFile = allTasksWithFile.filter(item => {
  const text = item.task.text;
  // â±ï¸ã‚’å«ã‚€ã‚¿ã‚¹ã‚¯ã§ã€ã‹ã¤ä»Šæ—¥ã®æ—¥ä»˜ï¼ˆğŸ“… YYYY-MM-DDï¼‰ã‚’å«ã‚€ã‚‚ã®
  return text.includes("â±ï¸") && text.includes(`ğŸ“… ${today}`);
});

const tasksWithTime = tasksWithTimeAndFile.map(item => item.task);

// ã‚¿ã‚¹ã‚¯ã¨ãƒ•ã‚¡ã‚¤ãƒ«æƒ…å ±ã®ãƒãƒƒãƒ”ãƒ³ã‚°ã‚’ä¿æŒï¼ˆã‚¿ã‚¹ã‚¯ã®ãƒ†ã‚­ã‚¹ãƒˆã‚’ã‚­ãƒ¼ã¨ã—ã¦ä½¿ç”¨ï¼‰
const taskFileMap = new Map();
tasksWithTimeAndFile.forEach(item => {
  taskFileMap.set(item.task.text, item.file);
});

if (tasksWithTime.length === 0) {
  dv.paragraph("_ä»Šæ—¥ã®ã‚¿ã‚¹ã‚¯ã¯ã‚ã‚Šã¾ã›ã‚“_");
} else {
    // ã‚¸ãƒ£ãƒ³ãƒ«è¨­å®šã‚’èª­ã¿è¾¼ã‚€
    const genreConfigPath = "03.ãƒ„ã‚§ãƒƒãƒ†ãƒ«ã‚«ã‚¹ãƒ†ãƒ³/030.ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹/ã‚¿ã‚¹ã‚¯ç®¡ç†/ã‚¸ãƒ£ãƒ³ãƒ«è¨­å®š.md";
    let genres = ["ãƒ‡ã‚¹ã‚¯ãƒ¯ãƒ¼ã‚¯", "å£²å ´ä½œæ¥­", "é¡§å®¢å¯¾å¿œ", "å®šå‹ä½œæ¥­", "å­¦ç¿’", "å¥åº·", "è¶£å‘³", "ãã®ä»–ãƒ—ãƒ©ã‚¤ãƒ™ãƒ¼ãƒˆ"]; // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ
    try {
      const genreConfigContent = await dv.io.load(genreConfigPath);
      if (genreConfigContent) {
        const genreMatch = genreConfigContent.match(/const TASK_GENRES = \[([\s\S]*?)\];/);
        if (genreMatch) {
          genres = genreMatch[1]
            .split(',')
            .map(g => g.trim().replace(/^["']|["']$/g, ''))
            .filter(g => g);
        }
      }
    } catch (error) {
      console.error("ã‚¸ãƒ£ãƒ³ãƒ«è¨­å®šã®èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼:", error);
    }
    
    // å®¹é‡è¨ˆç®—
    let totalMinutes = 0;
    let remainingMinutes = 0; // æœªå®Œäº†ã‚¿ã‚¹ã‚¯ã®å®¹é‡
    const genreBreakdown = {};

    tasksWithTime.forEach(task => {
      const timeMatch = task.text.match(/â±ï¸ (\d+)/);
      const duration = timeMatch ? parseInt(timeMatch[1]) : 0;
      totalMinutes += duration;
      
      // æœªå®Œäº†ã‚¿ã‚¹ã‚¯ã®å®¹é‡ã‚’è¨ˆç®—
      if (!task.completed) {
        remainingMinutes += duration;
      }

      // ã‚¸ãƒ£ãƒ³ãƒ«æŠ½å‡º
      for (const genre of genres) {
        if (task.text.includes(`#${genre}`)) {
          genreBreakdown[genre] = (genreBreakdown[genre] || 0) + duration;
          break;
        }
      }
    });

    // ã‚¿ã‚¹ã‚¯ä¸€è¦§ï¼ˆã‚¸ãƒ£ãƒ³ãƒ«é †ã§è¡¨ç¤ºï¼‰
    // è¡¨ç¤ºé †åºã®å®šç¾©
    const displayOrder = [
      "é¡§å®¢å¯¾å¿œ",
      "å£²å ´ä½œæ¥­",
      "ãƒ‡ã‚¹ã‚¯ãƒ¯ãƒ¼ã‚¯",
      "å®šå‹ä½œæ¥­",
      "å­¦ç¿’",
      "å¥åº·",
      "è¶£å‘³",
      "ãã®ä»–ãƒ—ãƒ©ã‚¤ãƒ™ãƒ¼ãƒˆ"
    ];
    
    // ã‚¿ã‚¹ã‚¯ã‚’ã‚¸ãƒ£ãƒ³ãƒ«åˆ¥ãƒ»å®Œäº†çŠ¶æ…‹åˆ¥ã«åˆ†é¡
    const tasksByGenre = {};
    const noGenreTasks = [];
    const getDurationMinutes = (text) => {
      const match = text.match(/â±ï¸ (\d+)/);
      return match ? parseInt(match[1], 10) : Number.MAX_SAFE_INTEGER;
    };
    
    tasksWithTime.forEach(task => {
      const timeMatch = task.text.match(/â±ï¸ (\d+)/);
      const duration = timeMatch ? `${timeMatch[1]}åˆ†` : "-";
      const durationMinutes = getDurationMinutes(task.text);
      
      // ç· åˆ‡æ—¥ã‚’æŠ½å‡ºï¼ˆâ° YYYY-MM-DDå½¢å¼ï¼‰
      const deadlineMatch = task.text.match(/â° (\d{4}-\d{2}-\d{2})/);
      let deadlineDisplay = "";
      if (deadlineMatch) {
        const deadlineDate = moment(deadlineMatch[1]);
        const today = moment().startOf('day');
        const daysDiff = deadlineDate.diff(today, 'days');
        
        if (daysDiff < 0) {
          deadlineDisplay = `ğŸ”´ç· åˆ‡éã (${deadlineDate.format("MM/DD")})`;
        } else if (daysDiff === 0) {
          deadlineDisplay = `ğŸŸ ç· åˆ‡ä»Šæ—¥ (${deadlineDate.format("MM/DD")})`;
        } else if (daysDiff <= 3) {
          deadlineDisplay = `ğŸŸ¡ç· åˆ‡${daysDiff}æ—¥å¾Œ (${deadlineDate.format("MM/DD")})`;
        } else {
          deadlineDisplay = `â°${deadlineDate.format("MM/DD")}`;
        }
      }
      
      const taskName = task.text
        .replace(/â±ï¸ \d+/, "")
        .replace(/ğŸ“… \d{4}-\d{2}-\d{2}/, "")
        .replace(/â° \d{4}-\d{2}-\d{2}/, "")
        .replace(/#\w+/g, "")
        .replace(/^- \[ \] /, "")
        .replace(/^- \[x\] /, "")
        .trim();
      
      const genre = genres.find(g => task.text.includes(`#${g}`)) || "-";
      const status = task.completed ? "âœ… å®Œäº†" : "â¬œ æœªå®Œäº†";
      
      // ç· åˆ‡æ—¥ã‚’ç‹¬ç«‹ã—ãŸãƒ‡ãƒ¼ã‚¿ã¨ã—ã¦ä¿å­˜ï¼ˆè¡¨ç¤ºç”¨ï¼‰
      const deadlineColumn = deadlineDisplay || "-";
      
      // ãƒ•ã‚¡ã‚¤ãƒ«æƒ…å ±ã‚‚å«ã‚ã‚‹ï¼ˆã‚¿ã‚¹ã‚¯ã®ãƒ†ã‚­ã‚¹ãƒˆã‚’ã‚­ãƒ¼ã¨ã—ã¦ä½¿ç”¨ï¼‰
      const taskFile = taskFileMap.get(task.text);
      const taskData = [taskName, genre, duration, status, deadlineColumn, task, task.completed, taskFile, durationMinutes];
      
      if (genre === "-") {
        noGenreTasks.push(taskData);
      } else {
        if (!tasksByGenre[genre]) {
          tasksByGenre[genre] = [];
        }
        tasksByGenre[genre].push(taskData);
      }
    });
    
    const sortTasksByDuration = (list) => list.sort((a, b) => a[8] - b[8]);

    // ã‚¸ãƒ£ãƒ³ãƒ«ã”ã¨ã«ã‚½ãƒ¼ãƒˆï¼ˆã‚¸ãƒ£ãƒ³ãƒ«å†…ã§æ™‚é–“ãŒçŸ­ã„é †ï¼‰
    Object.keys(tasksByGenre).forEach(genre => sortTasksByDuration(tasksByGenre[genre]));
    sortTasksByDuration(noGenreTasks);

    // æœªå®Œäº†ã‚¿ã‚¹ã‚¯ã¨å®Œäº†ã‚¿ã‚¹ã‚¯ã‚’åˆ†é›¢
    const incompleteTasks = [];
    const completedTasks = [];
    
    // æŒ‡å®šã•ã‚ŒãŸé †åºã§ã‚¸ãƒ£ãƒ³ãƒ«åˆ¥ã‚¿ã‚¹ã‚¯ã‚’è¿½åŠ ï¼ˆæœªå®Œäº†ã®ã¿ï¼‰
    for (const genre of displayOrder) {
      if (tasksByGenre[genre] && tasksByGenre[genre].length > 0) {
        tasksByGenre[genre].forEach(taskData => {
          if (taskData[6]) { // task.completed
            completedTasks.push(taskData);
          } else {
            incompleteTasks.push(taskData);
          }
        });
      }
    }
    
    // ãã®ä»–ã®ã‚¸ãƒ£ãƒ³ãƒ«ï¼ˆdisplayOrderã«å«ã¾ã‚Œã¦ã„ãªã„ã‚‚ã®ï¼‰ã‚’è¿½åŠ 
    for (const genre of Object.keys(tasksByGenre)) {
      if (!displayOrder.includes(genre)) {
        tasksByGenre[genre].forEach(taskData => {
          if (taskData[6]) { // task.completed
            completedTasks.push(taskData);
          } else {
            incompleteTasks.push(taskData);
          }
        });
      }
    }
    
    // ã‚¸ãƒ£ãƒ³ãƒ«ãªã—ã‚¿ã‚¹ã‚¯ã‚’è¿½åŠ 
    noGenreTasks.forEach(taskData => {
      if (taskData[6]) { // task.completed
        completedTasks.push(taskData);
      } else {
        incompleteTasks.push(taskData);
      }
    });
    
    // æœ€çµ‚çš„ãªã‚¿ã‚¹ã‚¯ãƒªã‚¹ãƒˆï¼ˆæœªå®Œäº†â†’å®Œäº†ã®é †ï¼‰
    const sortedTasks = [...incompleteTasks, ...completedTasks];
    
    // ãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹ä»˜ãã‚¿ã‚¹ã‚¯ç®¡ç†
    const taskContainer = dv.container;
    const taskListContainer = document.createElement('div');
    taskListContainer.style.marginBottom = '15px';
    
    const selectedTasks = new Set();
    
    // æ“ä½œãƒœã‚¿ãƒ³
    const actionButtons = document.createElement('div');
    actionButtons.style.marginBottom = '10px';
    actionButtons.style.display = 'flex';
    actionButtons.style.gap = '10px';
    actionButtons.style.flexWrap = 'wrap';
    
    const completeBtn = document.createElement('button');
    completeBtn.textContent = 'âœ… é¸æŠã—ãŸã‚¿ã‚¹ã‚¯ã‚’å®Œäº†';
    completeBtn.className = 'mod-cta';
    completeBtn.style.padding = '8px 16px';
    completeBtn.style.cursor = 'pointer';
    completeBtn.style.flex = '1';
    completeBtn.disabled = true;
    completeBtn.style.opacity = '0.5';
    
    const deleteBtn = document.createElement('button');
    deleteBtn.textContent = 'ğŸ—‘ï¸ é¸æŠã—ãŸã‚¿ã‚¹ã‚¯ã‚’å‰Šé™¤';
    deleteBtn.style.padding = '8px 16px';
    deleteBtn.style.cursor = 'pointer';
    deleteBtn.style.flex = '1';
    deleteBtn.disabled = true;
    deleteBtn.style.opacity = '0.5';
    
    const poolBtn = document.createElement('button');
    poolBtn.textContent = 'ğŸ“¦ é¸æŠã—ãŸã‚¿ã‚¹ã‚¯ã‚’ãƒ—ãƒ¼ãƒ«ã«ç§»å‹•';
    poolBtn.style.padding = '8px 16px';
    poolBtn.style.cursor = 'pointer';
    poolBtn.style.flex = '1';
    poolBtn.disabled = true;
    poolBtn.style.opacity = '0.5';
    
    const moveDateBtn = document.createElement('button');
    moveDateBtn.textContent = 'ğŸ“… é¸æŠã—ãŸã‚¿ã‚¹ã‚¯ã‚’æ—¥ä»˜ç§»å‹•';
    moveDateBtn.style.padding = '8px 16px';
    moveDateBtn.style.cursor = 'pointer';
    moveDateBtn.style.flex = '1';
    moveDateBtn.disabled = true;
    moveDateBtn.style.opacity = '0.5';
    
    const updateButtons = () => {
      const count = selectedTasks.size;
      if (count > 0) {
        completeBtn.disabled = false;
        completeBtn.style.opacity = '1';
        deleteBtn.disabled = false;
        deleteBtn.style.opacity = '1';
        poolBtn.disabled = false;
        poolBtn.style.opacity = '1';
        moveDateBtn.disabled = false;
        moveDateBtn.style.opacity = '1';
      } else {
        completeBtn.disabled = true;
        completeBtn.style.opacity = '0.5';
        deleteBtn.disabled = true;
        deleteBtn.style.opacity = '0.5';
        poolBtn.disabled = true;
        poolBtn.style.opacity = '0.5';
        moveDateBtn.disabled = true;
        moveDateBtn.style.opacity = '0.5';
      }
    };
    
    completeBtn.onclick = async () => {
      if (selectedTasks.size === 0) return;
      const selectedIndices = Array.from(selectedTasks).sort((a, b) => b - a);
      
      // ãƒ•ã‚¡ã‚¤ãƒ«ã”ã¨ã«ã‚°ãƒ«ãƒ¼ãƒ—åŒ–
      const tasksByFile = {};
      selectedIndices.forEach(index => {
        const taskData = sortedTasks[index];
        const taskFile = taskData[7]; // file object
        const originalLine = taskData[5].text; // task object
        if (!tasksByFile[taskFile.path]) {
          tasksByFile[taskFile.path] = [];
        }
        tasksByFile[taskFile.path].push(originalLine);
      });
      
      let totalSuccess = 0;
      for (const [filePath, taskLines] of Object.entries(tasksByFile)) {
        try {
          const file = app.vault.getAbstractFileByPath(filePath);
          if (!file) continue;
          
          let content = await app.vault.read(file);
          const lines = content.split('\n');
          let modified = false;
          
          for (const originalLine of taskLines) {
            const trimmedOriginal = originalLine.trim();
            
            // ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã‚’æŠ½å‡ºï¼ˆğŸ”— ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆåï¼‰
            const projectMatch = trimmedOriginal.match(/ğŸ”—\s*([^\s]+)/);
            const projectName = projectMatch ? projectMatch[1] : null;
            
            // ã‚¿ã‚¹ã‚¯åã‚’æŠ½å‡ºï¼ˆãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã‚’é™¤ãï¼‰
            const taskNameOnly = trimmedOriginal
              .replace(/^- \[[ x]\]\s*/, '')
              .replace(/\s*â±ï¸\s*\d+/, '')
              .replace(/\s*ğŸ“…\s*\d{4}-\d{2}-\d{2}/, '')
              .replace(/\s*â°\s*\d{4}-\d{2}-\d{2}/, '')
              .replace(/\s*ğŸ”—\s*[^\s]+/, '')
              .replace(/\s*#\w+/g, '')
              .trim();
            
            for (let i = 0; i < lines.length; i++) {
              const trimmedLine = lines[i].trim();
              // å®Œå…¨ä¸€è‡´ã¾ãŸã¯è¡ŒãŒå«ã¾ã‚Œã¦ã„ã‚‹å ´åˆ
              if (trimmedLine === trimmedOriginal || trimmedLine.includes(trimmedOriginal) || trimmedOriginal.includes(trimmedLine)) {
                // [ ] ã‚’ [x] ã«å¤‰æ›´
                if (lines[i].includes('- [ ]')) {
                  lines[i] = lines[i].replace(/- \[ \]/, '- [x]');
                  modified = true;
                  totalSuccess++;
                  break;
                }
              }
              
              // ã‚¿ã‚¹ã‚¯åãŒå«ã¾ã‚Œã¦ã„ã‚‹ã‹ç¢ºèª
              if (taskNameOnly && trimmedLine.includes(taskNameOnly)) {
                const lineTaskName = trimmedLine
                  .replace(/^- \[[ x]\]\s*/, '')
                  .replace(/\s*â±ï¸\s*\d+/, '')
                  .replace(/\s*ğŸ“…\s*\d{4}-\d{2}-\d{2}/, '')
                  .replace(/\s*â°\s*\d{4}-\d{2}-\d{2}/, '')
                  .replace(/\s*ğŸ”—\s*[^\s]+/, '')
                  .replace(/\s*#\w+/g, '')
                  .trim();
                
                if (lineTaskName === taskNameOnly && lines[i].includes('- [ ]')) {
                  lines[i] = lines[i].replace(/- \[ \]/, '- [x]');
                  modified = true;
                  totalSuccess++;
                  break;
                }
              }
            }
            
            // ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ã§ã‚‚å®Œäº†çŠ¶æ…‹ã«æ›´æ–°
            if (projectName) {
              const projectPath = `03.ãƒ„ã‚§ãƒƒãƒ†ãƒ«ã‚«ã‚¹ãƒ†ãƒ³/030.ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹/ã‚¿ã‚¹ã‚¯ç®¡ç†/ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆ/${projectName}.md`;
              const projectFile = app.vault.getAbstractFileByPath(projectPath);
              if (projectFile) {
                try {
                  let projectContent = await app.vault.read(projectFile);
                  const projectLines = projectContent.split('\n');
                  let projectModified = false;
                  
                  for (let i = 0; i < projectLines.length; i++) {
                    const line = projectLines[i];
                    const trimmedLine = line.trim();
                    
                    if (!line.includes('- [')) continue;
                    
                    // ã‚¿ã‚¹ã‚¯åãŒå«ã¾ã‚Œã¦ã„ã‚‹ã‹ç¢ºèªï¼ˆãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã¯é™¤ã„ã¦æ¯”è¼ƒï¼‰
                    if (taskNameOnly && trimmedLine.includes(taskNameOnly)) {
                      const lineTaskName = trimmedLine
                        .replace(/^- \[[ x]\]\s*/, '')
                        .replace(/\s*â±ï¸\s*\d+/, '')
                        .replace(/\s*ğŸ“…\s*\d{4}-\d{2}-\d{2}/, '')
                        .replace(/\s*â°\s*\d{4}-\d{2}-\d{2}/, '')
                        .replace(/\s*ğŸ”—\s*[^\s]+/, '')
                        .replace(/\s*#\w+/g, '')
                        .trim();
                      
                      if (lineTaskName === taskNameOnly && projectLines[i].includes('- [ ]')) {
                        projectLines[i] = projectLines[i].replace(/- \[ \]/, '- [x]');
                        projectModified = true;
                      }
                    }
                  }
                  
                  if (projectModified) {
                    projectContent = projectLines.join('\n');
                    await app.vault.modify(projectFile, projectContent);
                  }
                } catch (error) {
                  console.error(`ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãƒ•ã‚¡ã‚¤ãƒ« ${projectPath} ã®å‡¦ç†ã‚¨ãƒ©ãƒ¼:`, error);
                }
              }
            }
          }
          
          if (modified) {
            content = lines.join('\n');
            await app.vault.modify(file, content);
          }
        } catch (error) {
          console.error(`ãƒ•ã‚¡ã‚¤ãƒ« ${filePath} ã®å‡¦ç†ã‚¨ãƒ©ãƒ¼:`, error);
        }
      }
      
      if (totalSuccess > 0) {
        new Notice(`âœ… ${totalSuccess}ä»¶ã®ã‚¿ã‚¹ã‚¯ã‚’å®Œäº†ã—ã¾ã—ãŸ`);
        setTimeout(() => app.commands.executeCommandById('dataview:refresh-views'), 500);
      }
    };
    
    deleteBtn.onclick = async () => {
      if (selectedTasks.size === 0) {
        new Notice('âš ï¸ ã‚¿ã‚¹ã‚¯ã‚’é¸æŠã—ã¦ãã ã•ã„');
        return;
      }
      
      try {
        const selectedIndices = Array.from(selectedTasks).sort((a, b) => b - a);
        
        // ãƒ•ã‚¡ã‚¤ãƒ«ã”ã¨ã«ã‚°ãƒ«ãƒ¼ãƒ—åŒ–
        const tasksByFile = {};
        selectedIndices.forEach(index => {
          const taskData = sortedTasks[index];
          const taskFile = taskData[7]; // file object
          const originalLine = taskData[5].text; // task object
          if (!tasksByFile[taskFile.path]) {
            tasksByFile[taskFile.path] = [];
          }
          tasksByFile[taskFile.path].push(originalLine);
        });
        
        let totalSuccess = 0;
        for (const [filePath, taskLines] of Object.entries(tasksByFile)) {
          try {
            const file = app.vault.getAbstractFileByPath(filePath);
            if (!file) continue;
            
            let content = await app.vault.read(file);
            const lines = content.split('\n');
            let modified = false;
            const linesToRemove = new Set();
            
            for (const originalLine of taskLines) {
              const trimmedOriginal = originalLine.trim();
              
              // ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã‚’æŠ½å‡ºï¼ˆğŸ”— ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆåï¼‰
              const projectMatch = trimmedOriginal.match(/ğŸ”—\s*([^\s]+)/);
              const projectName = projectMatch ? projectMatch[1] : null;
              
              // ã‚¿ã‚¹ã‚¯åã‚’æŠ½å‡ºï¼ˆãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã‚’é™¤ãï¼‰
              const taskNameOnly = trimmedOriginal
                .replace(/^- \[[ x]\]\s*/, '')
                .replace(/\s*â±ï¸\s*\d+/, '')
                .replace(/\s*ğŸ“…\s*\d{4}-\d{2}-\d{2}/, '')
                .replace(/\s*â°\s*\d{4}-\d{2}-\d{2}/, '')
                .replace(/\s*ğŸ”—\s*[^\s]+/, '')
                .replace(/\s*#\w+/g, '')
                .trim();
              
              for (let i = 0; i < lines.length; i++) {
                const line = lines[i];
                const trimmedLine = line.trim();
                
                // ã‚¿ã‚¹ã‚¯è¡Œã‹ã©ã†ã‹ã‚’ç¢ºèª
                if (!line.includes('- [')) continue;
                
                // å®Œå…¨ä¸€è‡´ã‚’è©¦ã™
                if (trimmedLine === trimmedOriginal) {
                  linesToRemove.add(i);
                  modified = true;
                  totalSuccess++;
                  break;
                }
                
                // ã‚¿ã‚¹ã‚¯åãŒå«ã¾ã‚Œã¦ã„ã‚‹ã‹ç¢ºèª
                if (taskNameOnly && trimmedLine.includes(taskNameOnly)) {
                  // ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã‚’é™¤ã„ãŸéƒ¨åˆ†ã§æ¯”è¼ƒ
                  const lineTaskName = trimmedLine
                    .replace(/^- \[[ x]\]\s*/, '')
                    .replace(/\s*â±ï¸\s*\d+/, '')
                    .replace(/\s*ğŸ“…\s*\d{4}-\d{2}-\d{2}/, '')
                    .replace(/\s*â°\s*\d{4}-\d{2}-\d{2}/, '')
                    .replace(/\s*ğŸ”—\s*[^\s]+/, '')
                    .replace(/\s*#\w+/g, '')
                    .trim();
                  
                  if (lineTaskName === taskNameOnly) {
                    linesToRemove.add(i);
                    modified = true;
                    totalSuccess++;
                    break;
                  }
                }
              }
              
              // ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰ã‚‚å‰Šé™¤
              if (projectName) {
                const projectPath = `03.ãƒ„ã‚§ãƒƒãƒ†ãƒ«ã‚«ã‚¹ãƒ†ãƒ³/030.ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹/ã‚¿ã‚¹ã‚¯ç®¡ç†/ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆ/${projectName}.md`;
                const projectFile = app.vault.getAbstractFileByPath(projectPath);
                if (projectFile) {
                  try {
                    let projectContent = await app.vault.read(projectFile);
                    const projectLines = projectContent.split('\n');
                    const projectLinesToRemove = new Set();
                    let projectModified = false;
                    
                    for (let i = 0; i < projectLines.length; i++) {
                      const line = projectLines[i];
                      const trimmedLine = line.trim();
                      
                      if (!line.includes('- [')) continue;
                      
                      // ã‚¿ã‚¹ã‚¯åãŒå«ã¾ã‚Œã¦ã„ã‚‹ã‹ç¢ºèªï¼ˆãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã¯é™¤ã„ã¦æ¯”è¼ƒï¼‰
                      if (taskNameOnly && trimmedLine.includes(taskNameOnly)) {
                        const lineTaskName = trimmedLine
                          .replace(/^- \[[ x]\]\s*/, '')
                          .replace(/\s*â±ï¸\s*\d+/, '')
                          .replace(/\s*ğŸ“…\s*\d{4}-\d{2}-\d{2}/, '')
                          .replace(/\s*â°\s*\d{4}-\d{2}-\d{2}/, '')
                          .replace(/\s*ğŸ”—\s*[^\s]+/, '')
                          .replace(/\s*#\w+/g, '')
                          .trim();
                        
                        if (lineTaskName === taskNameOnly) {
                          projectLinesToRemove.add(i);
                          projectModified = true;
                        }
                      }
                    }
                    
                    if (projectModified) {
                      const sortedIndices = Array.from(projectLinesToRemove).sort((a, b) => b - a);
                      sortedIndices.forEach(index => {
                        projectLines.splice(index, 1);
                      });
                      projectContent = projectLines.join('\n');
                      await app.vault.modify(projectFile, projectContent);
                    }
                  } catch (error) {
                    console.error(`ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãƒ•ã‚¡ã‚¤ãƒ« ${projectPath} ã®å‡¦ç†ã‚¨ãƒ©ãƒ¼:`, error);
                  }
                }
              }
            }
            
            if (modified) {
              // å‰Šé™¤å¯¾è±¡ã®è¡Œã‚’é€†é †ã§å‰Šé™¤ï¼ˆã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ãŒãšã‚Œãªã„ã‚ˆã†ã«ï¼‰
              const sortedIndices = Array.from(linesToRemove).sort((a, b) => b - a);
              sortedIndices.forEach(index => {
                lines.splice(index, 1);
              });
              content = lines.join('\n');
              await app.vault.modify(file, content);
            }
          } catch (error) {
            console.error(`ãƒ•ã‚¡ã‚¤ãƒ« ${filePath} ã®å‡¦ç†ã‚¨ãƒ©ãƒ¼:`, error);
          }
        }
        
        if (totalSuccess > 0) {
          new Notice(`ğŸ—‘ï¸ ${totalSuccess}ä»¶ã®ã‚¿ã‚¹ã‚¯ã‚’å‰Šé™¤ã—ã¾ã—ãŸ`);
          setTimeout(() => {
            app.commands.executeCommandById('dataview:refresh-views');
          }, 500);
        } else {
          new Notice('âš ï¸ ã‚¿ã‚¹ã‚¯ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸ');
        }
      } catch (error) {
        console.error('ã‚¿ã‚¹ã‚¯å‰Šé™¤å‡¦ç†ã‚¨ãƒ©ãƒ¼:', error);
        new Notice(`âŒ ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ: ${error.message}`);
      }
    };
    
    poolBtn.onclick = async () => {
      if (selectedTasks.size === 0) {
        new Notice('âš ï¸ ã‚¿ã‚¹ã‚¯ã‚’é¸æŠã—ã¦ãã ã•ã„');
        return;
      }
      
      try {
        const poolPath = "03.ãƒ„ã‚§ãƒƒãƒ†ãƒ«ã‚«ã‚¹ãƒ†ãƒ³/030.ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹/ã‚¿ã‚¹ã‚¯ç®¡ç†/ã‚¿ã‚¹ã‚¯ãƒ—ãƒ¼ãƒ«/ã‚¿ã‚¹ã‚¯ãƒ—ãƒ¼ãƒ«.md";
        let poolFile = app.vault.getAbstractFileByPath(poolPath);
        if (!poolFile) {
          poolFile = await app.vault.create(poolPath, `# ğŸ“‹ ã‚¿ã‚¹ã‚¯ãƒ—ãƒ¼ãƒ«ï¼ˆæœªã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚¿ã‚¹ã‚¯ï¼‰\n\n## æœªã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚¿ã‚¹ã‚¯\n\n`);
        }
        
        let poolContent = await app.vault.read(poolFile);
        const selectedIndices = Array.from(selectedTasks).sort((a, b) => b - a);
        
        // ãƒ•ã‚¡ã‚¤ãƒ«ã”ã¨ã«ã‚°ãƒ«ãƒ¼ãƒ—åŒ–
        const tasksByFile = {};
        selectedIndices.forEach(index => {
          const taskData = sortedTasks[index];
          const taskFile = taskData[7]; // file object
          const originalLine = taskData[5].text; // task object
          if (!tasksByFile[taskFile.path]) {
            tasksByFile[taskFile.path] = [];
          }
          tasksByFile[taskFile.path].push(originalLine);
        });
        
        let totalSuccess = 0;
        for (const [filePath, taskLines] of Object.entries(tasksByFile)) {
          try {
            const file = app.vault.getAbstractFileByPath(filePath);
            if (!file) continue;
            
            let content = await app.vault.read(file);
            const lines = content.split('\n');
            const linesToRemove = new Set();
            
            taskLines.forEach(originalLine => {
              const trimmedOriginal = originalLine.trim();
              
              // å…ƒã®ãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰å‰Šé™¤
              for (let i = 0; i < lines.length; i++) {
                const trimmedLine = lines[i].trim();
                if (trimmedLine === trimmedOriginal || trimmedLine.includes(trimmedOriginal) || trimmedOriginal.includes(trimmedLine)) {
                  linesToRemove.add(i);
                  break;
                }
              }
              
              // ã‚¿ã‚¹ã‚¯ãƒ—ãƒ¼ãƒ«ã«è¿½åŠ ï¼ˆğŸ“…ã‚’å‰Šé™¤ï¼‰
              const poolTask = originalLine.replace(/\s*ğŸ“…\s*\d{4}-\d{2}-\d{2}/, '').trim();
              poolContent += poolTask + '\n';
              totalSuccess++;
            });
            
            // å…ƒã®ãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰å‰Šé™¤
            if (linesToRemove.size > 0) {
              const sortedIndices = Array.from(linesToRemove).sort((a, b) => b - a);
              sortedIndices.forEach(index => {
                lines.splice(index, 1);
              });
              content = lines.join('\n');
              await app.vault.modify(file, content);
            }
          } catch (error) {
            console.error(`ãƒ•ã‚¡ã‚¤ãƒ« ${filePath} ã®å‡¦ç†ã‚¨ãƒ©ãƒ¼:`, error);
          }
        }
        
        // ã‚¿ã‚¹ã‚¯ãƒ—ãƒ¼ãƒ«ã«ä¿å­˜
        if (totalSuccess > 0) {
          await app.vault.modify(poolFile, poolContent);
          new Notice(`ğŸ“¦ ${totalSuccess}ä»¶ã®ã‚¿ã‚¹ã‚¯ã‚’ãƒ—ãƒ¼ãƒ«ã«ç§»å‹•ã—ã¾ã—ãŸ`);
          setTimeout(() => {
            app.commands.executeCommandById('dataview:refresh-views');
          }, 500);
        }
      } catch (error) {
        console.error('ã‚¿ã‚¹ã‚¯ãƒ—ãƒ¼ãƒ«ç§»å‹•å‡¦ç†ã‚¨ãƒ©ãƒ¼:', error);
        new Notice(`âŒ ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ: ${error.message}`);
      }
    };
    
    moveDateBtn.onclick = async () => {
      console.log('moveDateBtn clicked, selectedTasks.size:', selectedTasks.size);
      if (selectedTasks.size === 0) {
        new Notice('âš ï¸ ã‚¿ã‚¹ã‚¯ã‚’é¸æŠã—ã¦ãã ã•ã„');
        return;
      }
      
      try {
        console.log('QuickAddãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã‚’ç¢ºèªä¸­...');
        // QuickAddãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã®ç¢ºèª
        const quickAddPlugin = app.plugins.plugins.quickadd;
        if (!quickAddPlugin || !quickAddPlugin.api) {
          new Notice('âŒ QuickAddãƒ—ãƒ©ã‚°ã‚¤ãƒ³ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
          console.error('QuickAddãƒ—ãƒ©ã‚°ã‚¤ãƒ³ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
          return;
        }
        const quickAddApi = quickAddPlugin.api;
        console.log('QuickAddãƒ—ãƒ©ã‚°ã‚¤ãƒ³ãŒè¦‹ã¤ã‹ã‚Šã¾ã—ãŸ');
        
        // æ˜æ—¥ã®æ—¥ä»˜ã‚’ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã¨ã—ã¦è¨­å®š
        const tomorrow = moment().add(1, 'day').format("YYYY-MM-DD");
        
        // ç§»å‹•å…ˆã®æ—¥ä»˜ã‚’å…¥åŠ›
        const newDateInput = await quickAddApi.inputPrompt(
          "ç§»å‹•å…ˆã®æ—¥ä»˜ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ (YYYY-MM-DD) - ç©ºç™½ã®å ´åˆã¯æ˜æ—¥",
          tomorrow
        );
        
        // ã‚­ãƒ£ãƒ³ã‚»ãƒ«ã•ã‚ŒãŸå ´åˆã‚„nullã®å ´åˆã¯å‡¦ç†ã‚’ä¸­æ–­
        if (newDateInput === null || newDateInput === undefined) {
          return;
        }
        
        // ç©ºç™½ã®å ´åˆã¯æ˜æ—¥ã«è¨­å®š
        const inputDate = newDateInput.trim() || tomorrow;
        
        // æ—¥ä»˜ã®å¦¥å½“æ€§ãƒã‚§ãƒƒã‚¯
        const newDate = moment(inputDate, "YYYY-MM-DD");
        if (!newDate.isValid()) {
          new Notice('ç„¡åŠ¹ãªæ—¥ä»˜å½¢å¼ã§ã™ã€‚YYYY-MM-DDå½¢å¼ã§å…¥åŠ›ã—ã¦ãã ã•ã„');
          return;
        }
        
        const newDateStr = newDate.format("YYYY-MM-DD");
        
        // ç§»å‹•å¾Œã®æ‰€è¦æ™‚é–“ã‚’å…¥åŠ›ï¼ˆç©ºæ¬„ãªã‚‰å¤‰æ›´ãªã—ï¼‰
        const newDurationInput = await quickAddApi.inputPrompt(
          "ç§»å‹•å¾Œã®æ‰€è¦æ™‚é–“(åˆ†)ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ï¼ˆç©ºæ¬„ãªã‚‰å¤‰æ›´ãªã—ï¼‰",
          ""
        );
        
        if (newDurationInput === null || newDurationInput === undefined) {
          return;
        }
        
        const durationTrim = newDurationInput.trim();
        let newDurationMinutes = null;
        if (durationTrim !== "") {
          const parsedDuration = parseInt(durationTrim, 10);
          if (isNaN(parsedDuration) || parsedDuration <= 0) {
            new Notice('ç„¡åŠ¹ãªæ™‚é–“ã§ã™ã€‚æ­£ã®æ•´æ•°ã§å…¥åŠ›ã—ã¦ãã ã•ã„');
            return;
          }
          newDurationMinutes = parsedDuration;
        }
        
        const applyDuration = (line) => {
          if (newDurationMinutes === null) return line;
          
          if (line.includes('â±ï¸')) {
            return line.replace(/â±ï¸\s*\d+/, `â±ï¸ ${newDurationMinutes}`);
          }
          
          const insertionTargets = ['ğŸ“…', 'â°', 'ğŸ”—', '#'];
          for (const target of insertionTargets) {
            const index = line.indexOf(target);
            if (index !== -1) {
              const before = line.slice(0, index).trimEnd();
              const after = line.slice(index);
              return `${before} â±ï¸ ${newDurationMinutes} ${after}`.replace(/\s{2,}/g, ' ').trim();
            }
          }
          
          return `${line.trim()} â±ï¸ ${newDurationMinutes}`;
        };
        
        const schedulePath = "03.ãƒ„ã‚§ãƒƒãƒ†ãƒ«ã‚«ã‚¹ãƒ†ãƒ³/030.ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹/ã‚¿ã‚¹ã‚¯ç®¡ç†/ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«";
        
        // é¸æŠã—ãŸã‚¿ã‚¹ã‚¯ã‚’å‡¦ç†
        const selectedIndices = Array.from(selectedTasks).sort((a, b) => b - a);
        
        // ãƒ•ã‚¡ã‚¤ãƒ«ã”ã¨ã«ã‚°ãƒ«ãƒ¼ãƒ—åŒ–
        const tasksByFile = {};
        selectedIndices.forEach(index => {
          if (index >= sortedTasks.length) {
            console.error(`ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ ${index} ãŒç¯„å›²å¤–ã§ã™`);
            return;
          }
          const taskData = sortedTasks[index];
          if (!taskData || !taskData[5] || !taskData[7]) {
            console.error(`ã‚¿ã‚¹ã‚¯ãƒ‡ãƒ¼ã‚¿ãŒä¸æ­£ã§ã™:`, taskData);
            return;
          }
          const taskFile = taskData[7]; // file object
          const originalLine = taskData[5].text; // task object
          if (!taskFile || !taskFile.path) {
            console.error(`ãƒ•ã‚¡ã‚¤ãƒ«æƒ…å ±ãŒä¸æ­£ã§ã™:`, taskFile);
            return;
          }
          if (!tasksByFile[taskFile.path]) {
            tasksByFile[taskFile.path] = [];
          }
          tasksByFile[taskFile.path].push(originalLine);
        });
        
        let totalSuccess = 0;
        
        // ç§»å‹•å…ˆã®ãƒ•ã‚¡ã‚¤ãƒ«ã‚’æº–å‚™
        const newFilePath = `${schedulePath}/${newDateStr}.md`;
        let newFile = app.vault.getAbstractFileByPath(newFilePath);
        if (!newFile) {
          newFile = await app.vault.create(newFilePath, `## ä»Šæ—¥ã®ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«\n\n`);
        }
        let newFileContent = await app.vault.read(newFile);
        
        // å„ãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰ã‚¿ã‚¹ã‚¯ã‚’å‰Šé™¤ã—ã€æ–°ã—ã„ãƒ•ã‚¡ã‚¤ãƒ«ã«è¿½åŠ 
        for (const [filePath, taskLines] of Object.entries(tasksByFile)) {
          try {
            const file = app.vault.getAbstractFileByPath(filePath);
            if (!file) continue;
            
            let content = await app.vault.read(file);
            const lines = content.split('\n');
            const linesToRemove = new Set();
            let modified = false;
            
            // ã¾ãšã€ã™ã¹ã¦ã®ã‚¿ã‚¹ã‚¯ã‚’æ–°ã—ã„ãƒ•ã‚¡ã‚¤ãƒ«ã«è¿½åŠ 
            for (const originalLine of taskLines) {
              const trimmedOriginal = originalLine.trim();
              
              // ãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹ã‚’å¿…ãšä»˜ä¸ï¼ˆæ¬ ã‘ã¦ã„ã‚‹å ´åˆã¯è¿½åŠ ï¼‰
              let updatedTaskLine = trimmedOriginal;
              
              if (newDurationMinutes !== null) {
                updatedTaskLine = applyDuration(updatedTaskLine);
              }
              
              if (updatedTaskLine.startsWith('- [')) {
                updatedTaskLine = updatedTaskLine.replace(/^- \[[ x]\]\s*/, '- [ ] ');
              } else {
                updatedTaskLine = `- [ ] ${updatedTaskLine.replace(/^- \[[ x]\]\s*/, '').trim()}`;
              }
              
              // æ–°ã—ã„æ—¥ä»˜ã§ã‚¿ã‚¹ã‚¯è¡Œã‚’ä½œæˆï¼ˆğŸ“…ã‚’æ›´æ–°ã¾ãŸã¯è¿½åŠ ï¼‰
              if (updatedTaskLine.includes('ğŸ“…')) {
                // ğŸ“…ãŒæ—¢ã«ã‚ã‚‹å ´åˆã¯æ›´æ–°
                updatedTaskLine = updatedTaskLine.replace(/ğŸ“…\s*\d{4}-\d{2}-\d{2}/, `ğŸ“… ${newDateStr}`);
              } else {
                // ğŸ“…ãŒãªã„å ´åˆã¯è¿½åŠ ï¼ˆãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã®æœ€å¾Œã«è¿½åŠ ï¼‰
                // â°ã®å‰ã«è¿½åŠ ã€ãªã‘ã‚Œã°æœ€å¾Œã«è¿½åŠ 
                if (updatedTaskLine.includes('â°')) {
                  updatedTaskLine = updatedTaskLine.replace(/(â°\s*\d{4}-\d{2}-\d{2})/, `ğŸ“… ${newDateStr} $1`);
                } else if (updatedTaskLine.includes('ğŸ”—')) {
                  updatedTaskLine = updatedTaskLine.replace(/(ğŸ”—\s*[^\s]+)/, `ğŸ“… ${newDateStr} $1`);
                } else {
                  // æœ€å¾Œã«è¿½åŠ 
                  updatedTaskLine = updatedTaskLine.trim() + ` ğŸ“… ${newDateStr}`;
                }
              }
              
              // æ–°ã—ã„ãƒ•ã‚¡ã‚¤ãƒ«ã«è¿½åŠ ï¼ˆé‡è¤‡ãƒã‚§ãƒƒã‚¯ï¼‰
              const trimmedUpdatedLine = updatedTaskLine.trim();
              if (!newFileContent.includes(trimmedUpdatedLine)) {
                newFileContent += trimmedUpdatedLine + '\n';
                totalSuccess++;
              }
            }
            
            // æ¬¡ã«ã€å…ƒã®ãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰å‰Šé™¤
            for (const originalLine of taskLines) {
              const trimmedOriginal = originalLine.trim();
              
              // ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã‚’æŠ½å‡ºï¼ˆğŸ”— ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆåï¼‰
              const projectMatch = trimmedOriginal.match(/ğŸ”—\s*([^\s]+)/);
              const projectName = projectMatch ? projectMatch[1] : null;
              
              // ã‚¿ã‚¹ã‚¯åã‚’æŠ½å‡ºï¼ˆãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã‚’é™¤ãï¼‰
              const taskNameOnly = trimmedOriginal
                .replace(/^- \[[ x]\]\s*/, '')
                .replace(/\s*â±ï¸\s*\d+/, '')
                .replace(/\s*ğŸ“…\s*\d{4}-\d{2}-\d{2}/, '')
                .replace(/\s*â°\s*\d{4}-\d{2}-\d{2}/, '')
                .replace(/\s*ğŸ”—\s*[^\s]+/, '')
                .replace(/\s*#\w+/g, '')
                .trim();
              
              // å…ƒã®ãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰å‰Šé™¤
              for (let i = 0; i < lines.length; i++) {
                const line = lines[i];
                const trimmedLine = line.trim();
                
                // å®Œå…¨ä¸€è‡´ã‚’è©¦ã™ï¼ˆ- [ ]ã§å§‹ã¾ã‚‰ãªã„ã‚¿ã‚¹ã‚¯ã‚‚å«ã‚€ï¼‰
                if (trimmedLine === trimmedOriginal) {
                  linesToRemove.add(i);
                  modified = true;
                  break;
                }
                
                // ã‚¿ã‚¹ã‚¯è¡Œã‹ã©ã†ã‹ã‚’ç¢ºèªï¼ˆ- [ ]ã§å§‹ã¾ã‚‹ã‹ã€ã‚¿ã‚¹ã‚¯åãŒå«ã¾ã‚Œã¦ã„ã‚‹ã‹ï¼‰
                const isTaskLine = line.includes('- [') || (taskNameOnly && trimmedLine.includes(taskNameOnly));
                if (!isTaskLine) continue;
                
                // ã‚¿ã‚¹ã‚¯åãŒå«ã¾ã‚Œã¦ã„ã‚‹ã‹ç¢ºèª
                if (taskNameOnly && trimmedLine.includes(taskNameOnly)) {
                  const lineTaskName = trimmedLine
                    .replace(/^- \[[ x]\]\s*/, '')
                    .replace(/\s*â±ï¸\s*\d+/, '')
                    .replace(/\s*ğŸ“…\s*\d{4}-\d{2}-\d{2}/, '')
                    .replace(/\s*â°\s*\d{4}-\d{2}-\d{2}/, '')
                    .replace(/\s*ğŸ”—\s*[^\s]+/, '')
                    .replace(/\s*#\w+/g, '')
                    .trim();
                  
                  if (lineTaskName === taskNameOnly) {
                    linesToRemove.add(i);
                    modified = true;
                    break;
                  }
                }
              }
              
              // ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ã®æ—¥ä»˜ã‚‚æ›´æ–°
              if (projectName) {
                const projectPath = `03.ãƒ„ã‚§ãƒƒãƒ†ãƒ«ã‚«ã‚¹ãƒ†ãƒ³/030.ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹/ã‚¿ã‚¹ã‚¯ç®¡ç†/ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆ/${projectName}.md`;
                const projectFile = app.vault.getAbstractFileByPath(projectPath);
                if (projectFile) {
                  try {
                    let projectContent = await app.vault.read(projectFile);
                    const projectLines = projectContent.split('\n');
                    let projectModified = false;
                    
                    for (let i = 0; i < projectLines.length; i++) {
                      const line = projectLines[i];
                      const trimmedLine = line.trim();
                      
                      // ã‚¿ã‚¹ã‚¯è¡Œã‹ã©ã†ã‹ã‚’ç¢ºèªï¼ˆ- [ ]ã§å§‹ã¾ã‚‹ã‹ã€ã‚¿ã‚¹ã‚¯åãŒå«ã¾ã‚Œã¦ã„ã‚‹ã‹ï¼‰
                      const isTaskLine = line.includes('- [') || (taskNameOnly && trimmedLine.includes(taskNameOnly));
                      if (!isTaskLine) continue;
                      
                      // ã‚¿ã‚¹ã‚¯åãŒå«ã¾ã‚Œã¦ã„ã‚‹ã‹ç¢ºèªï¼ˆãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã¯é™¤ã„ã¦æ¯”è¼ƒï¼‰
                      if (taskNameOnly && trimmedLine.includes(taskNameOnly)) {
                        const lineTaskName = trimmedLine
                          .replace(/^- \[[ x]\]\s*/, '')
                          .replace(/\s*â±ï¸\s*\d+/, '')
                          .replace(/\s*ğŸ“…\s*\d{4}-\d{2}-\d{2}/, '')
                          .replace(/\s*â°\s*\d{4}-\d{2}-\d{2}/, '')
                          .replace(/\s*ğŸ”—\s*[^\s]+/, '')
                          .replace(/\s*#\w+/g, '')
                          .trim();
                        
                        if (lineTaskName === taskNameOnly) {
                          if (newDurationMinutes !== null) {
                            projectLines[i] = applyDuration(projectLines[i]);
                          }
                          // æ—¥ä»˜ã‚’æ›´æ–°ã¾ãŸã¯è¿½åŠ 
                          if (projectLines[i].includes('ğŸ“…')) {
                            projectLines[i] = projectLines[i].replace(/ğŸ“…\s*\d{4}-\d{2}-\d{2}/, `ğŸ“… ${newDateStr}`);
                          } else {
                            // ğŸ“…ãŒãªã„å ´åˆã¯è¿½åŠ 
                            projectLines[i] = projectLines[i].trim() + ` ğŸ“… ${newDateStr}`;
                          }
                          projectModified = true;
                        }
                      }
                    }
                    
                    if (projectModified) {
                      projectContent = projectLines.join('\n');
                      await app.vault.modify(projectFile, projectContent);
                    }
                  } catch (error) {
                    console.error(`ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãƒ•ã‚¡ã‚¤ãƒ« ${projectPath} ã®å‡¦ç†ã‚¨ãƒ©ãƒ¼:`, error);
                  }
                }
              }
            }
            
            // å…ƒã®ãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰å‰Šé™¤
            if (modified) {
              const sortedIndices = Array.from(linesToRemove).sort((a, b) => b - a);
              sortedIndices.forEach(index => {
                lines.splice(index, 1);
              });
              content = lines.join('\n');
              await app.vault.modify(file, content);
            }
          } catch (error) {
            console.error(`ãƒ•ã‚¡ã‚¤ãƒ« ${filePath} ã®å‡¦ç†ã‚¨ãƒ©ãƒ¼:`, error);
          }
        }
        
        // æ–°ã—ã„ãƒ•ã‚¡ã‚¤ãƒ«ã«ä¿å­˜
        if (totalSuccess > 0) {
          await app.vault.modify(newFile, newFileContent);
          new Notice(`ğŸ“… ${totalSuccess}ä»¶ã®ã‚¿ã‚¹ã‚¯ã‚’${newDateStr}ã«ç§»å‹•ã—ã¾ã—ãŸ`);
          setTimeout(() => {
            app.commands.executeCommandById('dataview:refresh-views');
          }, 500);
        } else {
          new Notice('âš ï¸ ç§»å‹•ã§ããŸã‚¿ã‚¹ã‚¯ãŒã‚ã‚Šã¾ã›ã‚“ã§ã—ãŸ');
        }
      } catch (error) {
        console.error('ã‚¿ã‚¹ã‚¯ç§»å‹•å‡¦ç†ã‚¨ãƒ©ãƒ¼:', error);
        new Notice(`âŒ ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ: ${error.message}`);
      }
    };
    
    actionButtons.appendChild(completeBtn);
    actionButtons.appendChild(deleteBtn);
    actionButtons.appendChild(poolBtn);
    actionButtons.appendChild(moveDateBtn);
    taskListContainer.appendChild(actionButtons);
    
    // ãƒ†ãƒ¼ãƒ–ãƒ«ä½œæˆ
    const table = document.createElement('table');
    table.style.width = '100%';
    table.style.borderCollapse = 'collapse';
    
    const thead = document.createElement('thead');
    const headerRow = document.createElement('tr');
    ['', 'ã‚¿ã‚¹ã‚¯', 'ã‚¸ãƒ£ãƒ³ãƒ«', 'æ™‚é–“', 'çŠ¶æ…‹', 'ç· åˆ‡æ—¥', 'ãƒªãƒ³ã‚¯'].forEach(header => {
      const th = document.createElement('th');
      th.textContent = header;
      th.style.padding = '8px';
      th.style.textAlign = 'left';
      th.style.borderBottom = '2px solid var(--background-modifier-border)';
      headerRow.appendChild(th);
    });
    thead.appendChild(headerRow);
    table.appendChild(thead);
    
    const tbody = document.createElement('tbody');
    sortedTasks.forEach((taskData, index) => {
      const row = document.createElement('tr');
      
      const checkboxCell = document.createElement('td');
      const checkbox = document.createElement('input');
      checkbox.type = 'checkbox';
      checkbox.id = `today-task-${index}`;
      checkbox.style.cursor = 'pointer';
      checkbox.onchange = () => {
        if (checkbox.checked) selectedTasks.add(index);
        else selectedTasks.delete(index);
        updateButtons();
      };
      checkboxCell.appendChild(checkbox);
      checkboxCell.style.padding = '8px';
      row.appendChild(checkboxCell);
      
      ['taskName', 'genre', 'duration', 'status', 'deadlineColumn'].forEach((key, i) => {
        const cell = document.createElement('td');
        const value = key === 'taskName' ? taskData[0] : 
                     key === 'genre' ? taskData[1] :
                     key === 'duration' ? taskData[2] :
                     key === 'status' ? taskData[3] : taskData[4];
        cell.textContent = value || '-';
        cell.style.padding = '8px';
        row.appendChild(cell);
      });
      
      // ãƒªãƒ³ã‚¯åˆ—ã‚’è¿½åŠ 
      const linkCell = document.createElement('td');
      linkCell.style.padding = '8px';
      const linkPath = `${schedulePath}/${today}.md`;
      const link = document.createElement('a');
      link.textContent = 'ğŸ“„ é–‹ã';
      link.style.cursor = 'pointer';
      link.style.color = 'var(--link-color)';
      link.style.textDecoration = 'underline';
      link.onclick = async (e) => {
        e.preventDefault();
        const file = app.vault.getAbstractFileByPath(linkPath);
        if (file) {
          await app.workspace.getLeaf().openFile(file);
        } else {
          new Notice(`ãƒ•ã‚¡ã‚¤ãƒ«ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“: ${linkPath}`);
        }
      };
      linkCell.appendChild(link);
      row.appendChild(linkCell);
      
      tbody.appendChild(row);
    });
    table.appendChild(tbody);
    taskListContainer.appendChild(table);
    // taskListContainerã«è¦ç´ ãŒã‚ã‚‹å ´åˆã®ã¿è¿½åŠ 
    if (taskListContainer.children.length > 0) {
      taskContainer.appendChild(taskListContainer);
    }

    // å®¹é‡ä½¿ç”¨çŠ¶æ³
    const usagePercent = Math.round((totalMinutes / maxDailyMinutes) * 100);
    const filledBars = Math.max(0, Math.min(20, Math.floor(usagePercent / 5)));
    const emptyBars = Math.max(0, 20 - filledBars);
    const usageBar = "â–ˆ".repeat(filledBars) + "â–‘".repeat(emptyBars);
    dv.paragraph(`**å®¹é‡ä½¿ç”¨çŠ¶æ³**: ${totalMinutes}åˆ† / ${maxDailyMinutes}åˆ† (${usagePercent}%)\n${usageBar}`);
    
    // æœªå®Œäº†ã‚¿ã‚¹ã‚¯ã®å®¹é‡
    const remainingPercent = Math.round((remainingMinutes / maxDailyMinutes) * 100);
    const remainingFilledBars = Math.max(0, Math.min(20, Math.floor(remainingPercent / 5)));
    const remainingEmptyBars = Math.max(0, 20 - remainingFilledBars);
    const remainingBar = "â–ˆ".repeat(remainingFilledBars) + "â–‘".repeat(remainingEmptyBars);
    dv.paragraph(`**æ®‹ã‚Šã‚¿ã‚¹ã‚¯å®¹é‡**: ${remainingMinutes}åˆ† / ${maxDailyMinutes}åˆ† (${remainingPercent}%)\n${remainingBar}`);
    
    if (totalMinutes > maxDailyMinutes) {
      dv.paragraph(`âš ï¸ **å®¹é‡è¶…éè­¦å‘Š**: 1æ—¥ã®ä¸Šé™ï¼ˆ${maxDailyMinutes}åˆ†ï¼‰ã‚’è¶…ãˆã¦ã„ã¾ã™`);
    }
    
    dv.paragraph(`\nğŸ‘‰ [[${schedulePath}/${today}|è©³ç´°ã‚’è¦‹ã‚‹]] | [[03.ãƒ„ã‚§ãƒƒãƒ†ãƒ«ã‚«ã‚¹ãƒ†ãƒ³/030.ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹/ã‚¿ã‚¹ã‚¯ç®¡ç†/ã‚¿ã‚¹ã‚¯ç®¡ç†ãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰|ã‚¿ã‚¹ã‚¯ç®¡ç†ãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰]]`);
}
```

> [!info]- ğŸ“ ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆ
> 
> ```dataviewjs
> const projectPath = "03.ãƒ„ã‚§ãƒƒãƒ†ãƒ«ã‚«ã‚¹ãƒ†ãƒ³/030.ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹/ã‚¿ã‚¹ã‚¯ç®¡ç†/ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆ";
> const projectFiles = dv.pages(`"${projectPath}"`)
>   .where(p => p.file.name !== "README" && p.file.name !== "ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆ")
>   .sort(p => p.file.name, 'asc');
> 
> if (projectFiles.length === 0) {
>   dv.paragraph("_ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã¯ã‚ã‚Šã¾ã›ã‚“_");
> } else {
>   for (const project of projectFiles) {
>     const projectName = project.file.name.replace('.md', '');
>     dv.paragraph(`- [[${project.file.path}|${projectName}]]`);
>   }
>   
>   dv.paragraph(`\nğŸ‘‰ [[${projectPath}/README|ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆç®¡ç†]]`);
> }
> ```

> [!info]- ğŸ“… æ˜æ—¥ã®ã‚¿ã‚¹ã‚¯
> 
> ```dataviewjs
> const today = moment();
> const tomorrow = moment(today).add(1, 'day').format("YYYY-MM-DD");
> const schedulePath = "03.ãƒ„ã‚§ãƒƒãƒ†ãƒ«ã‚«ã‚¹ãƒ†ãƒ³/030.ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹/ã‚¿ã‚¹ã‚¯ç®¡ç†/ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«";
> const CONFIG_PATH = "03.ãƒ„ã‚§ãƒƒãƒ†ãƒ«ã‚«ã‚¹ãƒ†ãƒ³/030.ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹/ã‚¿ã‚¹ã‚¯ç®¡ç†/config/settings.json";
> const DEFAULT_MAX_DAILY_MINUTES = 360;
> let maxDailyMinutes = DEFAULT_MAX_DAILY_MINUTES;
> 
> try {
>   const configContent = await dv.io.load(CONFIG_PATH);
>   if (configContent) {
>     const config = JSON.parse(configContent);
>     if (Number.isFinite(config.maxDailyMinutes)) {
>       maxDailyMinutes = config.maxDailyMinutes;
>     }
>   }
> } catch (error) {
>   console.error("è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ã®èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼:", error);
> }
> 
> const tomorrowFile = dv.page(`${schedulePath}/${tomorrow}`);
> 
> if (!tomorrowFile) {
>   dv.paragraph("_æ˜æ—¥ã®ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ãƒ•ã‚¡ã‚¤ãƒ«ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“_");
> } else {
>   const tasks = tomorrowFile.file.tasks;
>   const tasksWithTime = tasks.where(t => {
>     const text = t.text;
>     return text.includes("â±ï¸");
>   }).array();
> 
>   if (tasksWithTime.length === 0) {
>     dv.paragraph("_æ˜æ—¥ã®ã‚¿ã‚¹ã‚¯ã¯ã‚ã‚Šã¾ã›ã‚“_");
>     return;
>   }
>   // ã‚¸ãƒ£ãƒ³ãƒ«è¨­å®šã‚’èª­ã¿è¾¼ã‚€
>   const genreConfigPath = "03.ãƒ„ã‚§ãƒƒãƒ†ãƒ«ã‚«ã‚¹ãƒ†ãƒ³/030.ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹/ã‚¿ã‚¹ã‚¯ç®¡ç†/ã‚¸ãƒ£ãƒ³ãƒ«è¨­å®š.md";
>   let genres = ["ãƒ‡ã‚¹ã‚¯ãƒ¯ãƒ¼ã‚¯", "å£²å ´ä½œæ¥­", "é¡§å®¢å¯¾å¿œ", "å®šå‹ä½œæ¥­", "å­¦ç¿’", "å¥åº·", "è¶£å‘³", "ãã®ä»–ãƒ—ãƒ©ã‚¤ãƒ™ãƒ¼ãƒˆ"]; // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ
>   try {
>     const genreConfigContent = await dv.io.load(genreConfigPath);
>     if (genreConfigContent) {
>       const genreMatch = genreConfigContent.match(/const TASK_GENRES = \[([\s\S]*?)\];/);
>       if (genreMatch) {
>         genres = genreMatch[1]
>           .split(',')
>           .map(g => g.trim().replace(/^["']|["']$/g, ''))
>           .filter(g => g);
>       }
>     }
>   } catch (error) {
>     console.error("ã‚¸ãƒ£ãƒ³ãƒ«è¨­å®šã®èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼:", error);
>   }
>   
>   // å®¹é‡è¨ˆç®—
>   let totalMinutes = 0;
>   const genreBreakdown = {};
> 
>   tasksWithTime.forEach(task => {
>     const timeMatch = task.text.match(/â±ï¸ (\d+)/);
>     const duration = timeMatch ? parseInt(timeMatch[1]) : 0;
>     totalMinutes += duration;
> 
>     // ã‚¸ãƒ£ãƒ³ãƒ«æŠ½å‡º
>     for (const genre of genres) {
>       if (task.text.includes(`#${genre}`)) {
>         genreBreakdown[genre] = (genreBreakdown[genre] || 0) + duration;
>         break;
>       }
>     }
>   });
> 
>   // ãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹ä»˜ãã‚¿ã‚¹ã‚¯ç®¡ç†
>   const taskContainer = dv.container;
>   const taskListContainer = document.createElement('div');
>   taskListContainer.style.marginBottom = '15px';
>   
>   const selectedTasks = new Set();
>   let taskDataList = tasksWithTime.map(task => {
>     const timeMatch = task.text.match(/â±ï¸ (\d+)/);
>     const duration = timeMatch ? `${timeMatch[1]}åˆ†` : "-";
>     const durationMinutes = timeMatch ? parseInt(timeMatch[1], 10) : Number.MAX_SAFE_INTEGER;
>     const taskName = task.text
>       .replace(/â±ï¸ \d+/, "")
>       .replace(/ğŸ“… \d{4}-\d{2}-\d{2}/, "")
>       .replace(/â° \d{4}-\d{2}-\d{2}/, "")
>       .replace(/#\w+/g, "")
>       .replace(/^- \[ \] /, "")
>       .replace(/^- \[x\] /, "")
>       .trim();
>     const genre = genres.find(g => task.text.includes(`#${g}`)) || "-";
>     const status = task.completed ? "âœ… å®Œäº†" : "â¬œ æœªå®Œäº†";
>     return { taskName, genre, duration, status, task, durationMinutes };
>   });
>     
>   const displayOrder = [
>     "é¡§å®¢å¯¾å¿œ",
>     "å£²å ´ä½œæ¥­",
>     "ãƒ‡ã‚¹ã‚¯ãƒ¯ãƒ¼ã‚¯",
>     "å®šå‹ä½œæ¥­",
>     "å­¦ç¿’",
>     "å¥åº·",
>     "è¶£å‘³",
>     "ãã®ä»–ãƒ—ãƒ©ã‚¤ãƒ™ãƒ¼ãƒˆ"
>   ];
>   
>   const tasksByGenre = {};
>   const noGenreTasks = [];
>   taskDataList.forEach(item => {
>     if (item.genre === "-") {
>       noGenreTasks.push(item);
>     } else {
>       if (!tasksByGenre[item.genre]) {
>         tasksByGenre[item.genre] = [];
>       }
>       tasksByGenre[item.genre].push(item);
>     }
>   });
>   
>   // ã‚¸ãƒ£ãƒ³ãƒ«ã”ã¨ã«ã‚½ãƒ¼ãƒˆï¼ˆã‚¸ãƒ£ãƒ³ãƒ«å†…ã§æ™‚é–“ãŒçŸ­ã„é †ï¼‰
>   const sortByDuration = (list) => list.sort((a, b) => a.durationMinutes - b.durationMinutes);
>   Object.keys(tasksByGenre).forEach(genre => sortByDuration(tasksByGenre[genre]));
>   sortByDuration(noGenreTasks);
>   
>   // æœªå®Œäº†ã‚¿ã‚¹ã‚¯ã¨å®Œäº†ã‚¿ã‚¹ã‚¯ã‚’åˆ†é›¢
>   const incompleteTasks = [];
>   const completedTasks = [];
>   
>   // æŒ‡å®šã•ã‚ŒãŸé †åºã§ã‚¸ãƒ£ãƒ³ãƒ«åˆ¥ã‚¿ã‚¹ã‚¯ã‚’è¿½åŠ 
>   displayOrder.forEach(genre => {
>     if (tasksByGenre[genre]) {
>       tasksByGenre[genre].forEach(item => {
>         if (item.task.completed) {
>           completedTasks.push(item);
>         } else {
>           incompleteTasks.push(item);
>         }
>       });
>     }
>   });
>   Object.keys(tasksByGenre).forEach(genre => {
>     if (!displayOrder.includes(genre)) {
>       tasksByGenre[genre].forEach(item => {
>         if (item.task.completed) {
>           completedTasks.push(item);
>         } else {
>           incompleteTasks.push(item);
>         }
>       });
>     }
>   });
>   noGenreTasks.forEach(item => {
>     if (item.task.completed) {
>       completedTasks.push(item);
>     } else {
>       incompleteTasks.push(item);
>     }
>   });
>   
>   // æœ€çµ‚çš„ãªã‚¿ã‚¹ã‚¯ãƒªã‚¹ãƒˆï¼ˆæœªå®Œäº†â†’å®Œäº†ã®é †ï¼‰
>   taskDataList = [...incompleteTasks, ...completedTasks];
>   
>   // æ“ä½œãƒœã‚¿ãƒ³
>   const actionButtons = document.createElement('div');
>   actionButtons.style.marginBottom = '10px';
>   actionButtons.style.display = 'flex';
>   actionButtons.style.gap = '10px';
>   actionButtons.style.flexWrap = 'wrap';
>   
>   const completeBtn = document.createElement('button');
>   completeBtn.textContent = 'âœ… é¸æŠã—ãŸã‚¿ã‚¹ã‚¯ã‚’å®Œäº†';
>   completeBtn.style.padding = '8px 16px';
>   completeBtn.style.cursor = 'pointer';
>   completeBtn.style.flex = '1';
>   completeBtn.disabled = true;
>   completeBtn.style.opacity = '0.5';
>   
>   const deleteBtn = document.createElement('button');
>   deleteBtn.textContent = 'ğŸ—‘ï¸ é¸æŠã—ãŸã‚¿ã‚¹ã‚¯ã‚’å‰Šé™¤';
>   deleteBtn.style.padding = '8px 16px';
>   deleteBtn.style.cursor = 'pointer';
>   deleteBtn.style.flex = '1';
>   deleteBtn.disabled = true;
>   deleteBtn.style.opacity = '0.5';
>   
>   const poolBtn = document.createElement('button');
>   poolBtn.textContent = 'ğŸ“¦ é¸æŠã—ãŸã‚¿ã‚¹ã‚¯ã‚’ãƒ—ãƒ¼ãƒ«ã«ç§»å‹•';
>   poolBtn.style.padding = '8px 16px';
>   poolBtn.style.cursor = 'pointer';
>   poolBtn.style.flex = '1';
>   poolBtn.disabled = true;
>   poolBtn.style.opacity = '0.5';
>   
>   const moveDateBtn = document.createElement('button');
>   moveDateBtn.textContent = 'ğŸ“… é¸æŠã—ãŸã‚¿ã‚¹ã‚¯ã‚’æ—¥ä»˜ç§»å‹•';
>   moveDateBtn.style.padding = '8px 16px';
>   moveDateBtn.style.cursor = 'pointer';
>   moveDateBtn.style.flex = '1';
>   moveDateBtn.disabled = true;
>   moveDateBtn.style.opacity = '0.5';
>   
>   const updateButtons = () => {
>     const count = selectedTasks.size;
>     if (count > 0) {
>       completeBtn.disabled = false;
>       completeBtn.style.opacity = '1';
>       deleteBtn.disabled = false;
>       deleteBtn.style.opacity = '1';
>       poolBtn.disabled = false;
>       poolBtn.style.opacity = '1';
>       moveDateBtn.disabled = false;
>       moveDateBtn.style.opacity = '1';
>     } else {
>       completeBtn.disabled = true;
>       completeBtn.style.opacity = '0.5';
>       deleteBtn.disabled = true;
>       deleteBtn.style.opacity = '0.5';
>       poolBtn.disabled = true;
>       poolBtn.style.opacity = '0.5';
>       moveDateBtn.disabled = true;
>       moveDateBtn.style.opacity = '0.5';
>     }
>   };
>   
>   completeBtn.onclick = async () => {
>     if (selectedTasks.size === 0) {
>       new Notice('âš ï¸ ã‚¿ã‚¹ã‚¯ã‚’é¸æŠã—ã¦ãã ã•ã„');
>       return;
>     }
>     
>     try {
>       const selectedIndices = Array.from(selectedTasks).sort((a, b) => b - a);
>       const filePath = tomorrowFile.file.path;
>       
>       if (!filePath) {
>         new Notice('âŒ ãƒ•ã‚¡ã‚¤ãƒ«ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
>         return;
>       }
>       
>       const file = app.vault.getAbstractFileByPath(filePath);
>       if (!file) {
>         new Notice('âŒ ãƒ•ã‚¡ã‚¤ãƒ«ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
>         return;
>       }
>       
>       let content = await app.vault.read(file);
>       const lines = content.split('\n');
>       let modified = false;
>       let successCount = 0;
>       
>       for (const index of selectedIndices) {
>         if (index >= taskDataList.length) {
>           console.error(`ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ ${index} ãŒç¯„å›²å¤–ã§ã™`);
>           continue;
>         }
>         
>         const task = taskDataList[index].task;
>         const taskText = task.text;
>         const trimmedTaskText = taskText.trim();
>         
>         // ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã‚’æŠ½å‡ºï¼ˆğŸ”— ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆåï¼‰
>         const projectMatch = trimmedTaskText.match(/ğŸ”—\s*([^\s]+)/);
>         const projectName = projectMatch ? projectMatch[1] : null;
>         
>         // ã‚¿ã‚¹ã‚¯åã‚’æŠ½å‡ºï¼ˆãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã‚’é™¤ãï¼‰
>         const taskNameOnly = taskText
>           .replace(/^- \[[ x]\]\s*/, '')
>           .replace(/\s*â±ï¸\s*\d+/, '')
>           .replace(/\s*ğŸ“…\s*\d{4}-\d{2}-\d{2}/, '')
>           .replace(/\s*â°\s*\d{4}-\d{2}-\d{2}/, '')
>           .replace(/\s*ğŸ”—\s*[^\s]+/, '')
>           .replace(/\s*#\w+/g, '')
>           .trim();
>         
>         for (let i = 0; i < lines.length; i++) {
>           const line = lines[i];
>           const trimmedLine = line.trim();
>           
>           // ã‚¿ã‚¹ã‚¯è¡Œã‹ã©ã†ã‹ã‚’ç¢ºèª
>           if (!line.includes('- [') || line.includes('- [x]')) {
>             continue;
>           }
>           
>           // å®Œå…¨ä¸€è‡´ã‚’è©¦ã™
>           if (trimmedLine === trimmedTaskText) {
>             if (line.includes('- [ ]')) {
>               lines[i] = line.replace(/- \[ \]/, '- [x]');
>               modified = true;
>               successCount++;
>               break;
>             }
>           }
>           
>           // ã‚¿ã‚¹ã‚¯åãŒå«ã¾ã‚Œã¦ã„ã‚‹ã‹ç¢ºèª
>           if (taskNameOnly && trimmedLine.includes(taskNameOnly) && line.includes('- [ ]')) {
>             // ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã‚’é™¤ã„ãŸéƒ¨åˆ†ã§æ¯”è¼ƒ
>             const lineTaskName = trimmedLine
>               .replace(/^- \[[ x]\]\s*/, '')
>               .replace(/\s*â±ï¸\s*\d+/, '')
>               .replace(/\s*ğŸ“…\s*\d{4}-\d{2}-\d{2}/, '')
>               .replace(/\s*â°\s*\d{4}-\d{2}-\d{2}/, '')
>               .replace(/\s*ğŸ”—\s*[^\s]+/, '')
>               .replace(/\s*#\w+/g, '')
>               .trim();
>             
>             if (lineTaskName === taskNameOnly) {
>               lines[i] = line.replace(/- \[ \]/, '- [x]');
>               modified = true;
>               successCount++;
>               break;
>             }
>           }
>         }
>         
>         // ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ã§ã‚‚å®Œäº†çŠ¶æ…‹ã«æ›´æ–°
>         if (projectName) {
>           const projectPath = `03.ãƒ„ã‚§ãƒƒãƒ†ãƒ«ã‚«ã‚¹ãƒ†ãƒ³/030.ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹/ã‚¿ã‚¹ã‚¯ç®¡ç†/ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆ/${projectName}.md`;
>           const projectFile = app.vault.getAbstractFileByPath(projectPath);
>           if (projectFile) {
>             try {
>               let projectContent = await app.vault.read(projectFile);
>               const projectLines = projectContent.split('\n');
>               let projectModified = false;
>               
>               for (let i = 0; i < projectLines.length; i++) {
>                 const line = projectLines[i];
>                 const trimmedLine = line.trim();
>                 
>                 if (!line.includes('- [')) continue;
>                 
>                 // ã‚¿ã‚¹ã‚¯åãŒå«ã¾ã‚Œã¦ã„ã‚‹ã‹ç¢ºèªï¼ˆãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã¯é™¤ã„ã¦æ¯”è¼ƒï¼‰
>                 if (taskNameOnly && trimmedLine.includes(taskNameOnly)) {
>                   const lineTaskName = trimmedLine
>                     .replace(/^- \[[ x]\]\s*/, '')
>                     .replace(/\s*â±ï¸\s*\d+/, '')
>                     .replace(/\s*ğŸ“…\s*\d{4}-\d{2}-\d{2}/, '')
>                     .replace(/\s*â°\s*\d{4}-\d{2}-\d{2}/, '')
>                     .replace(/\s*ğŸ”—\s*[^\s]+/, '')
>                     .replace(/\s*#\w+/g, '')
>                     .trim();
>                   
>                   if (lineTaskName === taskNameOnly && projectLines[i].includes('- [ ]')) {
>                     projectLines[i] = projectLines[i].replace(/- \[ \]/, '- [x]');
>                     projectModified = true;
>                   }
>                 }
>               }
>               
>               if (projectModified) {
>                 projectContent = projectLines.join('\n');
>                 await app.vault.modify(projectFile, projectContent);
>               }
>             } catch (error) {
>               console.error(`ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãƒ•ã‚¡ã‚¤ãƒ« ${projectPath} ã®å‡¦ç†ã‚¨ãƒ©ãƒ¼:`, error);
>             }
>           }
>         }
>       }
>       
>       if (modified) {
>         content = lines.join('\n');
>         await app.vault.modify(file, content);
>         new Notice(`âœ… ${successCount}ä»¶ã®ã‚¿ã‚¹ã‚¯ã‚’å®Œäº†ã—ã¾ã—ãŸ`);
>         setTimeout(() => {
>           app.commands.executeCommandById('dataview:refresh-views');
>         }, 500);
>       } else {
>         new Notice('âš ï¸ ã‚¿ã‚¹ã‚¯ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸ');
>       }
>     } catch (error) {
>       console.error('ã‚¿ã‚¹ã‚¯å®Œäº†å‡¦ç†ã‚¨ãƒ©ãƒ¼:', error);
>       new Notice(`âŒ ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ: ${error.message}`);
>     }
>   };
>     
>   deleteBtn.onclick = async () => {
>     if (selectedTasks.size === 0) {
>       new Notice('âš ï¸ ã‚¿ã‚¹ã‚¯ã‚’é¸æŠã—ã¦ãã ã•ã„');
>       return;
>     }
>     
>     try {
>       const selectedIndices = Array.from(selectedTasks).sort((a, b) => b - a);
>       const filePath = tomorrowFile.file.path;
>       
>       if (!filePath) {
>         new Notice('âŒ ãƒ•ã‚¡ã‚¤ãƒ«ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
>         return;
>       }
>       
>       const file = app.vault.getAbstractFileByPath(filePath);
>       if (!file) {
>         new Notice('âŒ ãƒ•ã‚¡ã‚¤ãƒ«ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
>         return;
>       }
>       
>       let content = await app.vault.read(file);
>       const lines = content.split('\n');
>       let modified = false;
>       const linesToRemove = new Set();
>       let successCount = 0;
>       
>       for (const index of selectedIndices) {
>         if (index >= taskDataList.length) {
>           console.error(`ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ ${index} ãŒç¯„å›²å¤–ã§ã™`);
>           continue;
>         }
>         
>         const task = taskDataList[index].task;
>         const taskText = task.text;
>         const trimmedTaskText = taskText.trim();
>         
>         // ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã‚’æŠ½å‡ºï¼ˆğŸ”— ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆåï¼‰
>         const projectMatch = trimmedTaskText.match(/ğŸ”—\s*([^\s]+)/);
>         const projectName = projectMatch ? projectMatch[1] : null;
>         
>         // ã‚¿ã‚¹ã‚¯åã‚’æŠ½å‡ºï¼ˆãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã‚’é™¤ãï¼‰
>         const taskNameOnly = taskText
>           .replace(/^- \[[ x]\]\s*/, '')
>           .replace(/\s*â±ï¸\s*\d+/, '')
>           .replace(/\s*ğŸ“…\s*\d{4}-\d{2}-\d{2}/, '')
>           .replace(/\s*â°\s*\d{4}-\d{2}-\d{2}/, '')
>           .replace(/\s*ğŸ”—\s*[^\s]+/, '')
>           .replace(/\s*#\w+/g, '')
>           .trim();
>         
>         for (let i = 0; i < lines.length; i++) {
>           const line = lines[i];
>           const trimmedLine = line.trim();
>           
>           // ã‚¿ã‚¹ã‚¯è¡Œã‹ã©ã†ã‹ã‚’ç¢ºèª
>           if (!line.includes('- [')) {
>             continue;
>           }
>           
>           // å®Œå…¨ä¸€è‡´ã‚’è©¦ã™
>           if (trimmedLine === trimmedTaskText) {
>             linesToRemove.add(i);
>             modified = true;
>             successCount++;
>             break;
>           }
>           
>           // ã‚¿ã‚¹ã‚¯åãŒå«ã¾ã‚Œã¦ã„ã‚‹ã‹ç¢ºèª
>           if (taskNameOnly && trimmedLine.includes(taskNameOnly)) {
>             // ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã‚’é™¤ã„ãŸéƒ¨åˆ†ã§æ¯”è¼ƒ
>             const lineTaskName = trimmedLine
>               .replace(/^- \[[ x]\]\s*/, '')
>               .replace(/\s*â±ï¸\s*\d+/, '')
>               .replace(/\s*ğŸ“…\s*\d{4}-\d{2}-\d{2}/, '')
>               .replace(/\s*â°\s*\d{4}-\d{2}-\d{2}/, '')
>               .replace(/\s*ğŸ”—\s*[^\s]+/, '')
>               .replace(/\s*#\w+/g, '')
>               .trim();
>             
>             if (lineTaskName === taskNameOnly) {
>               linesToRemove.add(i);
>               modified = true;
>               successCount++;
>               break;
>             }
>           }
>         }
>         
>         // ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰ã‚‚å‰Šé™¤
>         if (projectName) {
>           const projectPath = `03.ãƒ„ã‚§ãƒƒãƒ†ãƒ«ã‚«ã‚¹ãƒ†ãƒ³/030.ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹/ã‚¿ã‚¹ã‚¯ç®¡ç†/ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆ/${projectName}.md`;
>           const projectFile = app.vault.getAbstractFileByPath(projectPath);
>           if (projectFile) {
>             try {
>               let projectContent = await app.vault.read(projectFile);
>               const projectLines = projectContent.split('\n');
>               const projectLinesToRemove = new Set();
>               let projectModified = false;
>               
>               for (let i = 0; i < projectLines.length; i++) {
>                 const line = projectLines[i];
>                 const trimmedLine = line.trim();
>                 
>                 if (!line.includes('- [')) continue;
>                 
>                 // ã‚¿ã‚¹ã‚¯åãŒå«ã¾ã‚Œã¦ã„ã‚‹ã‹ç¢ºèªï¼ˆãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã¯é™¤ã„ã¦æ¯”è¼ƒï¼‰
>                 if (taskNameOnly && trimmedLine.includes(taskNameOnly)) {
>                   const lineTaskName = trimmedLine
>                     .replace(/^- \[[ x]\]\s*/, '')
>                     .replace(/\s*â±ï¸\s*\d+/, '')
>                     .replace(/\s*ğŸ“…\s*\d{4}-\d{2}-\d{2}/, '')
>                     .replace(/\s*â°\s*\d{4}-\d{2}-\d{2}/, '')
>                     .replace(/\s*ğŸ”—\s*[^\s]+/, '')
>                     .replace(/\s*#\w+/g, '')
>                     .trim();
>                   
>                   if (lineTaskName === taskNameOnly) {
>                     projectLinesToRemove.add(i);
>                     projectModified = true;
>                   }
>                 }
>               }
>               
>               if (projectModified) {
>                 const sortedIndices = Array.from(projectLinesToRemove).sort((a, b) => b - a);
>                 sortedIndices.forEach(index => {
>                   projectLines.splice(index, 1);
>                 });
>                 projectContent = projectLines.join('\n');
>                 await app.vault.modify(projectFile, projectContent);
>               }
>             } catch (error) {
>               console.error(`ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãƒ•ã‚¡ã‚¤ãƒ« ${projectPath} ã®å‡¦ç†ã‚¨ãƒ©ãƒ¼:`, error);
>             }
>           }
>         }
>       }
>       
>       if (modified) {
>         // å‰Šé™¤å¯¾è±¡ã®è¡Œã‚’é€†é †ã§å‰Šé™¤ï¼ˆã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ãŒãšã‚Œãªã„ã‚ˆã†ã«ï¼‰
>         const sortedIndices = Array.from(linesToRemove).sort((a, b) => b - a);
>         sortedIndices.forEach(index => {
>           lines.splice(index, 1);
>         });
>         content = lines.join('\n');
>         await app.vault.modify(file, content);
>         new Notice(`ğŸ—‘ï¸ ${successCount}ä»¶ã®ã‚¿ã‚¹ã‚¯ã‚’å‰Šé™¤ã—ã¾ã—ãŸ`);
>         setTimeout(() => {
>           app.commands.executeCommandById('dataview:refresh-views');
>         }, 500);
>       } else {
>         new Notice('âš ï¸ ã‚¿ã‚¹ã‚¯ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸ');
>       }
>     } catch (error) {
>       console.error('ã‚¿ã‚¹ã‚¯å‰Šé™¤å‡¦ç†ã‚¨ãƒ©ãƒ¼:', error);
>       new Notice(`âŒ ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ: ${error.message}`);
>     }
>   };
>     
>   poolBtn.onclick = async () => {
>     if (selectedTasks.size === 0) {
>       new Notice('âš ï¸ ã‚¿ã‚¹ã‚¯ã‚’é¸æŠã—ã¦ãã ã•ã„');
>       return;
>     }
>     
>     try {
>       const poolPath = "03.ãƒ„ã‚§ãƒƒãƒ†ãƒ«ã‚«ã‚¹ãƒ†ãƒ³/030.ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹/ã‚¿ã‚¹ã‚¯ç®¡ç†/ã‚¿ã‚¹ã‚¯ãƒ—ãƒ¼ãƒ«/ã‚¿ã‚¹ã‚¯ãƒ—ãƒ¼ãƒ«.md";
>       let poolFile = app.vault.getAbstractFileByPath(poolPath);
>       if (!poolFile) {
>         poolFile = await app.vault.create(poolPath, `# ğŸ“‹ ã‚¿ã‚¹ã‚¯ãƒ—ãƒ¼ãƒ«ï¼ˆæœªã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚¿ã‚¹ã‚¯ï¼‰\n\n## æœªã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚¿ã‚¹ã‚¯\n\n`);
>       }
>       
>       let poolContent = await app.vault.read(poolFile);
>       const selectedIndices = Array.from(selectedTasks).sort((a, b) => b - a);
>       const filePath = tomorrowFile.file.path;
>       const file = app.vault.getAbstractFileByPath(filePath);
>       
>       if (!file) {
>         new Notice('âŒ ãƒ•ã‚¡ã‚¤ãƒ«ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
>         return;
>       }
>       
>       let content = await app.vault.read(file);
>       const lines = content.split('\n');
>       const linesToRemove = new Set();
>       let successCount = 0;
>       
>       selectedIndices.forEach(index => {
>         if (index >= taskDataList.length) {
>           console.error(`ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ ${index} ãŒç¯„å›²å¤–ã§ã™`);
>           return;
>         }
>         
>         const task = taskDataList[index].task;
>         const taskText = task.text;
>         const trimmedTaskText = taskText.trim();
>         
>         const taskNameOnly = taskText
>           .replace(/^- \[[ x]\]\s*/, '')
>           .replace(/\s*â±ï¸\s*\d+/, '')
>           .replace(/\s*ğŸ“…\s*\d{4}-\d{2}-\d{2}/, '')
>           .replace(/\s*â°\s*\d{4}-\d{2}-\d{2}/, '')
>           .replace(/\s*#\w+/g, '')
>           .trim();
>         
>         // å…ƒã®ãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰å‰Šé™¤
>         for (let i = 0; i < lines.length; i++) {
>           const line = lines[i];
>           const trimmedLine = line.trim();
>           
>           if (!line.includes('- [')) continue;
>           
>           if (trimmedLine === trimmedTaskText) {
>             linesToRemove.add(i);
>             break;
>           }
>           
>           if (taskNameOnly && trimmedLine.includes(taskNameOnly)) {
>             const lineTaskName = trimmedLine
>               .replace(/^- \[[ x]\]\s*/, '')
>               .replace(/\s*â±ï¸\s*\d+/, '')
>               .replace(/\s*ğŸ“…\s*\d{4}-\d{2}-\d{2}/, '')
>               .replace(/\s*â°\s*\d{4}-\d{2}-\d{2}/, '')
>               .replace(/\s*#\w+/g, '')
>               .trim();
>             
>             if (lineTaskName === taskNameOnly) {
>               linesToRemove.add(i);
>               break;
>             }
>           }
>         }
>         
>         // ã‚¿ã‚¹ã‚¯ãƒ—ãƒ¼ãƒ«ã«è¿½åŠ ï¼ˆğŸ“…ã‚’å‰Šé™¤ï¼‰
>         const poolTask = taskText.replace(/\s*ğŸ“…\s*\d{4}-\d{2}-\d{2}/, '').trim();
>         poolContent += poolTask + '\n';
>         successCount++;
>       });
>       
>       // å…ƒã®ãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰å‰Šé™¤
>       if (linesToRemove.size > 0) {
>         const sortedIndices = Array.from(linesToRemove).sort((a, b) => b - a);
>         sortedIndices.forEach(index => {
>           lines.splice(index, 1);
>         });
>         content = lines.join('\n');
>         await app.vault.modify(file, content);
>       }
>       
>       // ã‚¿ã‚¹ã‚¯ãƒ—ãƒ¼ãƒ«ã«ä¿å­˜
>       if (successCount > 0) {
>         await app.vault.modify(poolFile, poolContent);
>         new Notice(`ğŸ“¦ ${successCount}ä»¶ã®ã‚¿ã‚¹ã‚¯ã‚’ãƒ—ãƒ¼ãƒ«ã«ç§»å‹•ã—ã¾ã—ãŸ`);
>         setTimeout(() => {
>           app.commands.executeCommandById('dataview:refresh-views');
>         }, 500);
>       }
>     } catch (error) {
>       console.error('ã‚¿ã‚¹ã‚¯ãƒ—ãƒ¼ãƒ«ç§»å‹•å‡¦ç†ã‚¨ãƒ©ãƒ¼:', error);
>       new Notice(`âŒ ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ: ${error.message}`);
>     }
>   };
>     
>   moveDateBtn.onclick = async () => {
>     if (selectedTasks.size === 0) {
>       new Notice('âš ï¸ ã‚¿ã‚¹ã‚¯ã‚’é¸æŠã—ã¦ãã ã•ã„');
>       return;
>     }
>     
>     try {
>       // QuickAddãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã®ç¢ºèª
>       const quickAddPlugin = app.plugins.plugins.quickadd;
>       if (!quickAddPlugin || !quickAddPlugin.api) {
>         new Notice('âŒ QuickAddãƒ—ãƒ©ã‚°ã‚¤ãƒ³ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
>         return;
>       }
>       const quickAddApi = quickAddPlugin.api;
>       
>       // æ˜æ—¥ã®æ—¥ä»˜ã‚’ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã¨ã—ã¦è¨­å®š
>       const tomorrow = moment().add(1, 'day').format("YYYY-MM-DD");
>       
>       // ç§»å‹•å…ˆã®æ—¥ä»˜ã‚’å…¥åŠ›
>       const newDateInput = await quickAddApi.inputPrompt(
>         "ç§»å‹•å…ˆã®æ—¥ä»˜ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ (YYYY-MM-DD) - ç©ºç™½ã®å ´åˆã¯æ˜æ—¥",
>         tomorrow
>       );
>       
>       // ã‚­ãƒ£ãƒ³ã‚»ãƒ«ã•ã‚ŒãŸå ´åˆã‚„nullã®å ´åˆã¯å‡¦ç†ã‚’ä¸­æ–­
>       if (newDateInput === null || newDateInput === undefined) {
>         return;
>       }
>       
>       // ç©ºç™½ã®å ´åˆã¯æ˜æ—¥ã«è¨­å®š
>       const inputDate = newDateInput.trim() || tomorrow;
>       
>       // æ—¥ä»˜ã®å¦¥å½“æ€§ãƒã‚§ãƒƒã‚¯
>       const newDate = moment(inputDate, "YYYY-MM-DD");
>       if (!newDate.isValid()) {
>         new Notice('ç„¡åŠ¹ãªæ—¥ä»˜å½¢å¼ã§ã™ã€‚YYYY-MM-DDå½¢å¼ã§å…¥åŠ›ã—ã¦ãã ã•ã„');
>         return;
>       }
>       
>       const newDateStr = newDate.format("YYYY-MM-DD");
>       
>       // ç§»å‹•å¾Œã®æ‰€è¦æ™‚é–“ã‚’å…¥åŠ›ï¼ˆç©ºæ¬„ãªã‚‰å¤‰æ›´ãªã—ï¼‰
>       const newDurationInput = await quickAddApi.inputPrompt(
>         "ç§»å‹•å¾Œã®æ‰€è¦æ™‚é–“(åˆ†)ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ï¼ˆç©ºæ¬„ãªã‚‰å¤‰æ›´ãªã—ï¼‰",
>         ""
>       );
>       
>       if (newDurationInput === null || newDurationInput === undefined) {
>         return;
>       }
>       
>       const durationTrim = newDurationInput.trim();
>       let newDurationMinutes = null;
>       if (durationTrim !== "") {
>         const parsedDuration = parseInt(durationTrim, 10);
>         if (isNaN(parsedDuration) || parsedDuration <= 0) {
>           new Notice('ç„¡åŠ¹ãªæ™‚é–“ã§ã™ã€‚æ­£ã®æ•´æ•°ã§å…¥åŠ›ã—ã¦ãã ã•ã„');
>           return;
>         }
>         newDurationMinutes = parsedDuration;
>       }
>       
>       const applyDuration = (line) => {
>         if (newDurationMinutes === null) return line;
>         
>         if (line.includes('â±ï¸')) {
>           return line.replace(/â±ï¸\s*\d+/, `â±ï¸ ${newDurationMinutes}`);
>         }
>         
>         const insertionTargets = ['ğŸ“…', 'â°', 'ğŸ”—', '#'];
>         for (const target of insertionTargets) {
>           const index = line.indexOf(target);
>           if (index !== -1) {
>             const before = line.slice(0, index).trimEnd();
>             const after = line.slice(index);
>             return `${before} â±ï¸ ${newDurationMinutes} ${after}`.replace(/\s{2,}/g, ' ').trim();
>           }
>         }
>         
>         return `${line.trim()} â±ï¸ ${newDurationMinutes}`;
>       };
>       
>       const schedulePath = "03.ãƒ„ã‚§ãƒƒãƒ†ãƒ«ã‚«ã‚¹ãƒ†ãƒ³/030.ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹/ã‚¿ã‚¹ã‚¯ç®¡ç†/ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«";
>       
>       // é¸æŠã—ãŸã‚¿ã‚¹ã‚¯ã‚’å‡¦ç†
>       const selectedIndices = Array.from(selectedTasks).sort((a, b) => b - a);
>       const filePath = tomorrowFile.file.path;
>       const file = app.vault.getAbstractFileByPath(filePath);
>       
>       if (!file) {
>         new Notice('âŒ ãƒ•ã‚¡ã‚¤ãƒ«ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
>         return;
>       }
>       
>       let content = await app.vault.read(file);
>       const lines = content.split('\n');
>       const linesToRemove = new Set();
>       let modified = false;
>       let totalSuccess = 0;
>       
>       // ç§»å‹•å…ˆã®ãƒ•ã‚¡ã‚¤ãƒ«ã‚’æº–å‚™
>       const newFilePath = `${schedulePath}/${newDateStr}.md`;
>       let newFile = app.vault.getAbstractFileByPath(newFilePath);
>       if (!newFile) {
>         newFile = await app.vault.create(newFilePath, `## ä»Šæ—¥ã®ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«\n\n`);
>       }
>       let newFileContent = await app.vault.read(newFile);
>       
>       for (const index of selectedIndices) {
>         if (index >= taskDataList.length) continue;
>         
>         const task = taskDataList[index].task;
>         const taskText = task.text;
>         const trimmedTaskText = taskText.trim();
>         
>         // ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã‚’æŠ½å‡º
>         const projectMatch = trimmedTaskText.match(/ğŸ”—\s*([^\s]+)/);
>         const projectName = projectMatch ? projectMatch[1] : null;
>         
>         // ã‚¿ã‚¹ã‚¯åã‚’æŠ½å‡º
>         const taskNameOnly = trimmedTaskText
>           .replace(/^- \[[ x]\]\s*/, '')
>           .replace(/\s*â±ï¸\s*\d+/, '')
>           .replace(/\s*ğŸ“…\s*\d{4}-\d{2}-\d{2}/, '')
>           .replace(/\s*â°\s*\d{4}-\d{2}-\d{2}/, '')
>           .replace(/\s*ğŸ”—\s*[^\s]+/, '')
>           .replace(/\s*#\w+/g, '')
>           .trim();
>         
>         // æ–°ã—ã„æ—¥ä»˜ã§ã‚¿ã‚¹ã‚¯è¡Œã‚’ä½œæˆ
>         let updatedTaskLine = taskText;
>         
>         if (newDurationMinutes !== null) {
>           updatedTaskLine = applyDuration(updatedTaskLine);
>         }
>         
>         if (updatedTaskLine.includes('ğŸ“…')) {
>           updatedTaskLine = updatedTaskLine.replace(/ğŸ“…\s*\d{4}-\d{2}-\d{2}/, `ğŸ“… ${newDateStr}`);
>         } else {
>           if (updatedTaskLine.includes('â°')) {
>             updatedTaskLine = updatedTaskLine.replace(/(â°\s*\d{4}-\d{2}-\d{2})/, `ğŸ“… ${newDateStr} $1`);
>           } else if (updatedTaskLine.includes('ğŸ”—')) {
>             updatedTaskLine = updatedTaskLine.replace(/(ğŸ”—\s*[^\s]+)/, `ğŸ“… ${newDateStr} $1`);
>           } else {
>             updatedTaskLine = updatedTaskLine.trim() + ` ğŸ“… ${newDateStr}`;
>           }
>         }
>         
>         // æ–°ã—ã„ãƒ•ã‚¡ã‚¤ãƒ«ã«è¿½åŠ 
>         const trimmedUpdatedLine = updatedTaskLine.trim();
>         if (!newFileContent.includes(trimmedUpdatedLine)) {
>           newFileContent += trimmedUpdatedLine + '\n';
>           totalSuccess++;
>         }
>         
>         // å…ƒã®ãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰å‰Šé™¤
>         for (let i = 0; i < lines.length; i++) {
>           const line = lines[i];
>           const trimmedLine = line.trim();
>           
>           if (trimmedLine === trimmedTaskText) {
>             linesToRemove.add(i);
>             modified = true;
>             break;
>           }
>           
>           const isTaskLine = line.includes('- [') || (taskNameOnly && trimmedLine.includes(taskNameOnly));
>           if (!isTaskLine) continue;
>           
>           if (taskNameOnly && trimmedLine.includes(taskNameOnly)) {
>             const lineTaskName = trimmedLine
>               .replace(/^- \[[ x]\]\s*/, '')
>               .replace(/\s*â±ï¸\s*\d+/, '')
>               .replace(/\s*ğŸ“…\s*\d{4}-\d{2}-\d{2}/, '')
>               .replace(/\s*â°\s*\d{4}-\d{2}-\d{2}/, '')
>               .replace(/\s*ğŸ”—\s*[^\s]+/, '')
>               .replace(/\s*#\w+/g, '')
>               .trim();
>             
>             if (lineTaskName === taskNameOnly) {
>               linesToRemove.add(i);
>               modified = true;
>               break;
>             }
>           }
>         }
>         
>         // ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ã®æ—¥ä»˜ã‚‚æ›´æ–°
>         if (projectName) {
>           const projectPath = `03.ãƒ„ã‚§ãƒƒãƒ†ãƒ«ã‚«ã‚¹ãƒ†ãƒ³/030.ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹/ã‚¿ã‚¹ã‚¯ç®¡ç†/ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆ/${projectName}.md`;
>           const projectFile = app.vault.getAbstractFileByPath(projectPath);
>           if (projectFile) {
>             try {
>               let projectContent = await app.vault.read(projectFile);
>               const projectLines = projectContent.split('\n');
>               let projectModified = false;
>               
>               for (let i = 0; i < projectLines.length; i++) {
>                 const line = projectLines[i];
>                 const trimmedLine = line.trim();
>                 
>                 const isTaskLine = line.includes('- [') || (taskNameOnly && trimmedLine.includes(taskNameOnly));
>                 if (!isTaskLine) continue;
>                 
>                 if (taskNameOnly && trimmedLine.includes(taskNameOnly)) {
>                   const lineTaskName = trimmedLine
>                     .replace(/^- \[[ x]\]\s*/, '')
>                     .replace(/\s*â±ï¸\s*\d+/, '')
>                     .replace(/\s*ğŸ“…\s*\d{4}-\d{2}-\d{2}/, '')
>                     .replace(/\s*â°\s*\d{4}-\d{2}-\d{2}/, '')
>                     .replace(/\s*ğŸ”—\s*[^\s]+/, '')
>                     .replace(/\s*#\w+/g, '')
>                     .trim();
>                   
>                   if (lineTaskName === taskNameOnly) {
>                     if (newDurationMinutes !== null) {
>                       projectLines[i] = applyDuration(projectLines[i]);
>                     }
>                     if (projectLines[i].includes('ğŸ“…')) {
>                       projectLines[i] = projectLines[i].replace(/ğŸ“…\s*\d{4}-\d{2}-\d{2}/, `ğŸ“… ${newDateStr}`);
>                     } else {
>                       projectLines[i] = projectLines[i].trim() + ` ğŸ“… ${newDateStr}`;
>                     }
>                     projectModified = true;
>                   }
>                 }
>               }
>               
>               if (projectModified) {
>                 projectContent = projectLines.join('\n');
>                 await app.vault.modify(projectFile, projectContent);
>               }
>             } catch (error) {
>               console.error(`ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãƒ•ã‚¡ã‚¤ãƒ« ${projectPath} ã®å‡¦ç†ã‚¨ãƒ©ãƒ¼:`, error);
>             }
>           }
>         }
>       }
>       
>       // å…ƒã®ãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰å‰Šé™¤
>       if (modified) {
>         const sortedIndices = Array.from(linesToRemove).sort((a, b) => b - a);
>         sortedIndices.forEach(index => {
>           lines.splice(index, 1);
>         });
>         content = lines.join('\n');
>         await app.vault.modify(file, content);
>       }
>       
>       // æ–°ã—ã„ãƒ•ã‚¡ã‚¤ãƒ«ã«ä¿å­˜
>       if (totalSuccess > 0) {
>         await app.vault.modify(newFile, newFileContent);
>         new Notice(`ğŸ“… ${totalSuccess}ä»¶ã®ã‚¿ã‚¹ã‚¯ã‚’${newDateStr}ã«ç§»å‹•ã—ã¾ã—ãŸ`);
>         setTimeout(() => {
>           app.commands.executeCommandById('dataview:refresh-views');
>         }, 500);
>       } else {
>         new Notice('âš ï¸ ç§»å‹•ã§ããŸã‚¿ã‚¹ã‚¯ãŒã‚ã‚Šã¾ã›ã‚“ã§ã—ãŸ');
>       }
>     } catch (error) {
>       console.error('ã‚¿ã‚¹ã‚¯ç§»å‹•å‡¦ç†ã‚¨ãƒ©ãƒ¼:', error);
>       new Notice(`âŒ ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ: ${error.message}`);
>     }
>   };
>     
>   actionButtons.appendChild(completeBtn);
>   actionButtons.appendChild(deleteBtn);
>   actionButtons.appendChild(poolBtn);
>   actionButtons.appendChild(moveDateBtn);
>   taskListContainer.appendChild(actionButtons);
>   
>   // ãƒ†ãƒ¼ãƒ–ãƒ«
>   const table = document.createElement('table');
>   table.style.width = '100%';
>   table.style.borderCollapse = 'collapse';
>   const thead = document.createElement('thead');
>   const headerRow = document.createElement('tr');
>   ['', 'ã‚¿ã‚¹ã‚¯', 'ã‚¸ãƒ£ãƒ³ãƒ«', 'æ™‚é–“', 'çŠ¶æ…‹', 'ãƒªãƒ³ã‚¯'].forEach(header => {
>     const th = document.createElement('th');
>     th.textContent = header;
>     th.style.padding = '8px';
>     th.style.textAlign = 'left';
>     th.style.borderBottom = '2px solid var(--background-modifier-border)';
>     headerRow.appendChild(th);
>   });
>   thead.appendChild(headerRow);
>   table.appendChild(thead);
>   const tbody = document.createElement('tbody');
>   taskDataList.forEach((taskData, index) => {
>     const row = document.createElement('tr');
>     const checkboxCell = document.createElement('td');
>     const checkbox = document.createElement('input');
>     checkbox.type = 'checkbox';
>     checkbox.id = `tomorrow-task-${index}`;
>     checkbox.style.cursor = 'pointer';
>     checkbox.onchange = () => {
>       if (checkbox.checked) selectedTasks.add(index);
>       else selectedTasks.delete(index);
>       updateButtons();
>     };
>     checkboxCell.appendChild(checkbox);
>     checkboxCell.style.padding = '8px';
>     row.appendChild(checkboxCell);
>     [taskData.taskName, taskData.genre, taskData.duration, taskData.status].forEach(value => {
>       const cell = document.createElement('td');
>       cell.textContent = value;
>       cell.style.padding = '8px';
>       row.appendChild(cell);
>     });
>     
>     // ãƒªãƒ³ã‚¯åˆ—ã‚’è¿½åŠ 
>     const linkCell = document.createElement('td');
>     linkCell.style.padding = '8px';
>     const linkPath = `${schedulePath}/${tomorrow}.md`;
>     const link = document.createElement('a');
>     link.textContent = 'ğŸ“„ é–‹ã';
>     link.style.cursor = 'pointer';
>     link.style.color = 'var(--link-color)';
>     link.style.textDecoration = 'underline';
>     link.onclick = async (e) => {
>       try {
>         e.preventDefault();
>         const file = app.vault.getAbstractFileByPath(linkPath);
>         if (file) {
>           await app.workspace.getLeaf().openFile(file);
>         } else {
>           new Notice(`ãƒ•ã‚¡ã‚¤ãƒ«ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“: ${linkPath}`);
>         }
>       } catch (error) {
>         console.error('ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é–‹ãéš›ã®ã‚¨ãƒ©ãƒ¼:', error);
>         new Notice(`ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é–‹ãéš›ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ: ${error.message}`);
>       }
>     };
>     linkCell.appendChild(link);
>     row.appendChild(linkCell);
>     
>     tbody.appendChild(row);
>   });
>   table.appendChild(tbody);
>   taskListContainer.appendChild(table);
>   // taskListContainerã«è¦ç´ ãŒã‚ã‚‹å ´åˆã®ã¿è¿½åŠ 
>   if (taskListContainer.children.length > 0) {
>     taskContainer.appendChild(taskListContainer);
>   }
> 
>   // å®¹é‡ä½¿ç”¨çŠ¶æ³
>   const usagePercent = Math.round((totalMinutes / maxDailyMinutes) * 100);
>   const filledBars = Math.max(0, Math.min(20, Math.floor(usagePercent / 5)));
>   const emptyBars = Math.max(0, 20 - filledBars);
>   const usageBar = "â–ˆ".repeat(filledBars) + "â–‘".repeat(emptyBars);
>   dv.paragraph(`**å®¹é‡ä½¿ç”¨çŠ¶æ³**: ${totalMinutes}åˆ† / ${maxDailyMinutes}åˆ† (${usagePercent}%)\n${usageBar}`);
>   
>   if (totalMinutes > maxDailyMinutes) {
>     dv.paragraph(`âš ï¸ **å®¹é‡è¶…éè­¦å‘Š**: 1æ—¥ã®ä¸Šé™ï¼ˆ${maxDailyMinutes}åˆ†ï¼‰ã‚’è¶…ãˆã¦ã„ã¾ã™`);
>   }
>   
>   dv.paragraph(`\nğŸ‘‰ [[${schedulePath}/${tomorrow}|è©³ç´°ã‚’è¦‹ã‚‹]]`);
> }
> ```

> [!info]- ğŸ“… ä»Šé€±ã®ã‚¿ã‚¹ã‚¯ï¼ˆç¹°ã‚Šè¿”ã—ã‚¿ã‚¹ã‚¯é™¤ãï¼‰
> 
> ```dataviewjs
> const today = moment().startOf('day');
> const schedulePath = "03.ãƒ„ã‚§ãƒƒãƒ†ãƒ«ã‚«ã‚¹ãƒ†ãƒ³/030.ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹/ã‚¿ã‚¹ã‚¯ç®¡ç†/ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«";
> const dailyTasksPath = "03.ãƒ„ã‚§ãƒƒãƒ†ãƒ«ã‚«ã‚¹ãƒ†ãƒ³/030.ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹/ã‚¿ã‚¹ã‚¯ç®¡ç†/ç¹°ã‚Šè¿”ã—ã‚¿ã‚¹ã‚¯/æ¯æ—¥.md";
> const weeklyTasksPath = "03.ãƒ„ã‚§ãƒƒãƒ†ãƒ«ã‚«ã‚¹ãƒ†ãƒ³/030.ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹/ã‚¿ã‚¹ã‚¯ç®¡ç†/ç¹°ã‚Šè¿”ã—ã‚¿ã‚¹ã‚¯/æ¯é€±.md";
> const CONFIG_PATH = "03.ãƒ„ã‚§ãƒƒãƒ†ãƒ«ã‚«ã‚¹ãƒ†ãƒ³/030.ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹/ã‚¿ã‚¹ã‚¯ç®¡ç†/config/settings.json";
> const DEFAULT_MAX_DAILY_MINUTES = 360;
> const DEFAULT_WORKING_DAYS = 5;
> let maxDailyMinutes = DEFAULT_MAX_DAILY_MINUTES;
> let workingDaysPerWeek = DEFAULT_WORKING_DAYS;
> 
> try {
> const configContent = await dv.io.load(CONFIG_PATH);
> if (configContent) {
> const config = JSON.parse(configContent);
> if (Number.isFinite(config.maxDailyMinutes)) {
> maxDailyMinutes = config.maxDailyMinutes;
> }
> if (Number.isFinite(config.workingDaysPerWeek)) {
> workingDaysPerWeek = config.workingDaysPerWeek;
> }
> }
> } catch (error) {
> console.error("è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ã®èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼:", error);
> }
> 
> // ç¹°ã‚Šè¿”ã—ã‚¿ã‚¹ã‚¯ã®åå‰ã‚’å–å¾—
> const recurringTaskNames = new Set();
> 
> try {
> // æ¯æ—¥ã®ç¹°ã‚Šè¿”ã—ã‚¿ã‚¹ã‚¯
> const dailyContent = await dv.io.load(dailyTasksPath);
> if (dailyContent) {
> // ã‚¿ã‚¹ã‚¯è¡Œã‚’æŠ½å‡ºï¼ˆãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹ã‹ã‚‰å§‹ã¾ã‚‹è¡Œï¼‰
> const dailyLines = dailyContent.split('\n');
> for (const line of dailyLines) {
> const match = line.match(/^-\s+\[[ x]\]\s+(.+?)(?:\s+#|\s+â±ï¸|\s+ğŸ”|$)/);
> if (match) {
> const taskName = match[1].trim();
> if (taskName) {
> recurringTaskNames.add(taskName);
> }
> }
> }
> }
> 
> // æ¯é€±ã®ç¹°ã‚Šè¿”ã—ã‚¿ã‚¹ã‚¯
> const weeklyContent = await dv.io.load(weeklyTasksPath);
> if (weeklyContent) {
> // ã‚¿ã‚¹ã‚¯è¡Œã‚’æŠ½å‡ºï¼ˆãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹ã‹ã‚‰å§‹ã¾ã‚‹è¡Œï¼‰
> const weeklyLines = weeklyContent.split('\n');
> for (const line of weeklyLines) {
> const match = line.match(/^-\s+\[[ x]\]\s+(.+?)(?:\s+#|\s+â±ï¸|\s+ğŸ”|$)/);
> if (match) {
> const taskName = match[1].trim();
> if (taskName) {
> recurringTaskNames.add(taskName);
> }
> }
> }
> }
> } catch (error) {
> console.error("ç¹°ã‚Šè¿”ã—ã‚¿ã‚¹ã‚¯å®šç¾©ã®èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼:", error);
> }
> 
> // ã‚´ãƒŸå‡ºã—ç³»ã‚¿ã‚¹ã‚¯ã‚‚ç¹°ã‚Šè¿”ã—ã‚¿ã‚¹ã‚¯ã¨ã—ã¦é™¤å¤–
> recurringTaskNames.add("æ˜æ—¥ãƒ—ãƒ©ã‚´ãƒŸ");
> recurringTaskNames.add("æ˜æ—¥ä¸ç‡ƒã”ã¿");
> recurringTaskNames.add("æ˜æ—¥æ®µãƒœãƒ¼ãƒ«æ¨ã¦ã‚‹æ—¥");
> recurringTaskNames.add("ãƒ—ãƒ©ã‚´ãƒŸ");
> recurringTaskNames.add("ä¸ç‡ƒã”ã¿");
> recurringTaskNames.add("æ®µãƒœãƒ¼ãƒ«æ¨ã¦ã‚‹æ—¥");
> 
> 
> // ä»Šé€±ã®é–‹å§‹ï¼ˆæœˆæ›œæ—¥ï¼‰ã‚’è¨ˆç®—
> const startOfWeek = moment(today).startOf('isoWeek'); // æœˆæ›œæ—¥
> 
> const weekTasks = [];
> 
> // ç¹°ã‚Šè¿”ã—ã‚¿ã‚¹ã‚¯ã‹ã©ã†ã‹ã‚’åˆ¤å®šã™ã‚‹é–¢æ•°
> function isRecurringTask(taskText) {
> // ğŸ”ã‚’å«ã‚€å ´åˆã¯ç¹°ã‚Šè¿”ã—ã‚¿ã‚¹ã‚¯
> if (taskText.includes("ğŸ”")) return true;
> 
> // ã‚¿ã‚¹ã‚¯åã‚’æŠ½å‡º
> // Dataviewã®task.textã¯ "- [ ] ã‚¿ã‚¹ã‚¯å #ã‚¸ãƒ£ãƒ³ãƒ« â±ï¸ 60 ğŸ“… 2025-11-12" ã®å½¢å¼
> // ã¾ãŸã¯ "ã‚¿ã‚¹ã‚¯å #ã‚¸ãƒ£ãƒ³ãƒ« â±ï¸ 60 ğŸ“… 2025-11-12" ã®å½¢å¼ï¼ˆãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹ãªã—ï¼‰
> let taskName = "";
> const matchWithCheckbox = taskText.match(/^-\s+\[[ x]\]\s+(.+?)(?:\s+#|\s+â±ï¸|\s+ğŸ“…|$)/);
> const matchWithoutCheckbox = taskText.match(/^(.+?)(?:\s+#|\s+â±ï¸|\s+ğŸ“…|$)/);
> 
> if (matchWithCheckbox) {
> taskName = matchWithCheckbox[1].trim();
> } else if (matchWithoutCheckbox) {
> taskName = matchWithoutCheckbox[1].trim();
> }
> 
> if (!taskName) return false;
> 
> // ç¹°ã‚Šè¿”ã—ã‚¿ã‚¹ã‚¯ãƒªã‚¹ãƒˆã¨ç…§åˆï¼ˆå®Œå…¨ä¸€è‡´ã¾ãŸã¯éƒ¨åˆ†ä¸€è‡´ï¼‰
> for (const recurringName of recurringTaskNames) {
> // å®Œå…¨ä¸€è‡´
> if (taskName === recurringName) {
> return true;
> }
> // éƒ¨åˆ†ä¸€è‡´ï¼ˆã€Œæ˜æ—¥ãƒ—ãƒ©ã‚´ãƒŸã€ã«ã€Œãƒ—ãƒ©ã‚´ãƒŸã€ãŒå«ã¾ã‚Œã‚‹ãªã©ï¼‰
> if (taskName.includes(recurringName) || recurringName.includes(taskName)) {
> return true;
> }
> }
> 
> return false;
> }
> 
> // é€±ã®å„æ—¥ã‚’ãƒ«ãƒ¼ãƒ—
> for (let i = 0; i < 7; i++) {
> const date = moment(startOfWeek).add(i, 'days');
> const dateStr = date.format("YYYY-MM-DD");
> const dateFile = dv.page(`${schedulePath}/${dateStr}`);
> 
> if (dateFile) {
> const tasks = dateFile.file.tasks;
> const tasksWithTime = tasks.where(t => {
> const text = t.text;
> // â±ï¸ã‚’å«ã‚€ã‚¿ã‚¹ã‚¯ã®ã¿ï¼ˆå®¹é‡ç®¡ç†å¯¾è±¡ã®ã‚¿ã‚¹ã‚¯ï¼‰
> // ç¹°ã‚Šè¿”ã—ã‚¿ã‚¹ã‚¯ã¯é™¤å¤–
> return text.includes("â±ï¸") && !isRecurringTask(text);
> }).array();
> 
> if (tasksWithTime.length > 0) {
> weekTasks.push({
> date: dateStr,
> dateLabel: date.format("MM/DD(ddd)"),
> tasks: tasksWithTime
> });
> }
> }
> }
> 
> if (weekTasks.length === 0) {
> dv.paragraph("_ä»Šé€±ã®ã‚¿ã‚¹ã‚¯ã¯ã‚ã‚Šã¾ã›ã‚“_");
> return;
> }
> // ã‚¸ãƒ£ãƒ³ãƒ«è¨­å®šã‚’èª­ã¿è¾¼ã‚€
> const genreConfigPath = "03.ãƒ„ã‚§ãƒƒãƒ†ãƒ«ã‚«ã‚¹ãƒ†ãƒ³/030.ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹/ã‚¿ã‚¹ã‚¯ç®¡ç†/ã‚¸ãƒ£ãƒ³ãƒ«è¨­å®š.md";
> let genres = ["ãƒ‡ã‚¹ã‚¯ãƒ¯ãƒ¼ã‚¯", "å£²å ´ä½œæ¥­", "é¡§å®¢å¯¾å¿œ", "å®šå‹ä½œæ¥­", "å­¦ç¿’", "å¥åº·", "è¶£å‘³", "ãã®ä»–ãƒ—ãƒ©ã‚¤ãƒ™ãƒ¼ãƒˆ"]; // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ
> try {
> const genreConfigContent = await dv.io.load(genreConfigPath);
> if (genreConfigContent) {
> const genreMatch = genreConfigContent.match(/const TASK_GENRES = \[([\s\S]*?)\];/);
> if (genreMatch) {
> genres = genreMatch[1]
> .split(',')
> .map(g => g.trim().replace(/^["']|["']$/g, ''))
> .filter(g => g);
> }
> }
> } catch (error) {
> console.error("ã‚¸ãƒ£ãƒ³ãƒ«è¨­å®šã®èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼:", error);
> }
> 
> // å®¹é‡è¨ˆç®—
> let weekTotalMinutes = 0;
> const weekGenreBreakdown = {};
> 
> weekTasks.forEach(dayData => {
> dayData.tasks.forEach(task => {
> const timeMatch = task.text.match(/â±ï¸ (\d+)/);
> const duration = timeMatch ? parseInt(timeMatch[1]) : 0;
> weekTotalMinutes += duration;
> 
> // ã‚¸ãƒ£ãƒ³ãƒ«æŠ½å‡º
> for (const genre of genres) {
> if (task.text.includes(`#${genre}`)) {
> weekGenreBreakdown[genre] = (weekGenreBreakdown[genre] || 0) + duration;
> break;
> }
> }
> });
> });
> 
> // ã‚¿ã‚¹ã‚¯ä¸€è¦§ï¼ˆã‚¸ãƒ£ãƒ³ãƒ«é †ãƒ»å®Œäº†ã‚¿ã‚¹ã‚¯ã‚’ä¸‹ã«ï¼‰
> // è¡¨ç¤ºé †åºã®å®šç¾©
> const displayOrder = [
> "é¡§å®¢å¯¾å¿œ",
> "å£²å ´ä½œæ¥­",
> "ãƒ‡ã‚¹ã‚¯ãƒ¯ãƒ¼ã‚¯",
> "å®šå‹ä½œæ¥­",
> "å­¦ç¿’",
> "å¥åº·",
> "è¶£å‘³",
> "ãã®ä»–ãƒ—ãƒ©ã‚¤ãƒ™ãƒ¼ãƒˆ"
> ];
> 
> // å…¨ã‚¿ã‚¹ã‚¯ã‚’åé›†
> const allTasks = [];
> for (const dayData of weekTasks) {
> const filePath = `${schedulePath}/${dayData.date}.md`;
> let fileContent = null;
> let fileModified = false;
> 
> // ãƒ•ã‚¡ã‚¤ãƒ«ã®å†…å®¹ã‚’ä¸€åº¦ã ã‘èª­ã¿è¾¼ã‚€
> try {
> const file = app.vault.getAbstractFileByPath(filePath);
> if (file) {
> fileContent = await app.vault.read(file);
> }
> } catch (error) {
> console.error(`ãƒ•ã‚¡ã‚¤ãƒ« ${filePath} ã®èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼:`, error);
> }
> 
> if (!fileContent) continue;
> 
> let lines = fileContent.split('\n');
> const processedTaskLines = new Set(); // å‡¦ç†æ¸ˆã¿ã®ã‚¿ã‚¹ã‚¯è¡Œã‚’è¿½è·¡
> 
> // ã¾ãšã€ãƒ•ã‚¡ã‚¤ãƒ«å†…ã®ã™ã¹ã¦ã®ã‚¿ã‚¹ã‚¯è¡Œã‚’æ¤œå‡ºã—ã¦ä¿®æ­£
> for (let i = 0; i < lines.length; i++) {
> const line = lines[i];
> const trimmedLine = line.trim();
> 
> // - [ ]ã§å§‹ã¾ã£ã¦ã„ãªã„ãŒã€â±ï¸ã‚„ğŸ“…ãŒå«ã¾ã‚Œã¦ã„ã‚‹è¡Œã‚’ä¿®æ­£
> if (trimmedLine && !trimmedLine.startsWith('- [') && 
> (trimmedLine.includes('â±ï¸') || trimmedLine.includes('ğŸ“…') || trimmedLine.includes('#'))) {
> // ã‚¤ãƒ³ãƒ‡ãƒ³ãƒˆã‚’ä¿æŒã—ã¦å¤‰æ›
> const indentMatch = line.match(/^(\s*)/);
> const indent = indentMatch ? indentMatch[1] : '';
> lines[i] = `${indent}- [ ] ${trimmedLine}`;
> fileModified = true;
> }
> }
> 
> // ãƒ•ã‚¡ã‚¤ãƒ«ãŒå¤‰æ›´ã•ã‚ŒãŸå ´åˆã¯ã€ãƒ•ã‚¡ã‚¤ãƒ«ã‚’æ›´æ–°
> if (fileModified) {
> const updatedContent = lines.join('\n');
> try {
> const file = app.vault.getAbstractFileByPath(filePath);
> if (file) {
> await app.vault.modify(file, updatedContent);
> // æ›´æ–°å¾Œã®å†…å®¹ã‚’ä½¿ç”¨
> lines = updatedContent.split('\n');
> }
> } catch (error) {
> console.error(`ãƒ•ã‚¡ã‚¤ãƒ« ${filePath} ã®æ›´æ–°ã‚¨ãƒ©ãƒ¼:`, error);
> }
> }
> 
> // ãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰ç›´æ¥ã™ã¹ã¦ã®ã‚¿ã‚¹ã‚¯ã‚’èª­ã¿è¾¼ã‚€ï¼ˆDataviewãŒèªè­˜ã—ã¦ã„ãªã„ã‚¿ã‚¹ã‚¯ã‚‚å«ã‚€ï¼‰
> for (let i = 0; i < lines.length; i++) {
> const line = lines[i];
> const trimmedLine = line.trim();
> 
> // - [ ]ã§å§‹ã¾ã‚‹ã‚¿ã‚¹ã‚¯è¡Œã‚’ç¢ºèª
> if (trimmedLine.startsWith('- [') && (trimmedLine.includes('[ ]') || trimmedLine.includes('[x]'))) {
> // â±ï¸ãŒå«ã¾ã‚Œã¦ã„ã‚‹ã‹ç¢ºèªï¼ˆå®¹é‡ç®¡ç†å¯¾è±¡ã®ã‚¿ã‚¹ã‚¯ã®ã¿ï¼‰
> if (trimmedLine.includes('â±ï¸')) {
> // ç¹°ã‚Šè¿”ã—ã‚¿ã‚¹ã‚¯ã‹ã©ã†ã‹ã‚’ç¢ºèª
> if (isRecurringTask(trimmedLine)) continue;
> 
> // ã‚¿ã‚¹ã‚¯åã‚’æŠ½å‡º
> const taskName = trimmedLine
> .replace(/â±ï¸ \d+/, "")
> .replace(/ğŸ“… \d{4}-\d{2}-\d{2}/, "")
> .replace(/#\w+/g, "")
> .replace(/^- \[ \] /, "")
> .replace(/^- \[x\] /, "")
> .trim();
> 
> // æ—¢ã«å‡¦ç†æ¸ˆã¿ã‹ç¢ºèªï¼ˆé‡è¤‡ã‚’é¿ã‘ã‚‹ãŸã‚ï¼‰
> const taskKey = `${dayData.date}-${taskName}`;
> if (processedTaskLines.has(taskKey)) continue;
> processedTaskLines.add(taskKey);
> 
> const timeMatch = trimmedLine.match(/â±ï¸ (\d+)/);
> const duration = timeMatch ? `${timeMatch[1]}åˆ†` : "-";
> const taskGenre = genres.find(g => trimmedLine.includes(`#${g}`)) || "-";
> const isCompleted = trimmedLine.includes('[x]');
> const taskStatus = isCompleted ? "âœ… å®Œäº†" : "â¬œ æœªå®Œäº†";
> 
> allTasks.push({
> dateLabel: dayData.dateLabel,
> dateStr: dayData.date,
> taskName: taskName,
> genre: taskGenre,
> duration: duration,
> status: taskStatus,
> completed: isCompleted,
> genreOrder: displayOrder.indexOf(taskGenre) >= 0 ? displayOrder.indexOf(taskGenre) : 999,
> task: { text: trimmedLine, completed: isCompleted },
> filePath: filePath
> });
> }
> }
> }
> }
> 
> // ã‚½ãƒ¼ãƒˆ: æœªå®Œäº†â†’å®Œäº†ã€ã‚¸ãƒ£ãƒ³ãƒ«é †
> allTasks.sort((a, b) => {
> // ã¾ãšå®Œäº†çŠ¶æ…‹ã§ã‚½ãƒ¼ãƒˆï¼ˆæœªå®Œäº†ãŒä¸Šï¼‰
> if (a.completed !== b.completed) {
> return a.completed ? 1 : -1;
> }
> // å®Œäº†çŠ¶æ…‹ãŒåŒã˜å ´åˆã¯ã‚¸ãƒ£ãƒ³ãƒ«é †
> if (a.genreOrder !== b.genreOrder) {
> return a.genreOrder - b.genreOrder;
> }
> // ã‚¸ãƒ£ãƒ³ãƒ«ã‚‚åŒã˜å ´åˆã¯æ—¥ä»˜é †
> return a.dateLabel.localeCompare(b.dateLabel);
> });
> 
> if (allTasks.length > 0) {
> // ãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹ä»˜ãã‚¿ã‚¹ã‚¯ç®¡ç†
> const taskContainer = dv.container;
> const taskListContainer = document.createElement('div');
> taskListContainer.style.marginBottom = '15px';
> 
> const selectedTasks = new Set();
> 
> // æ“ä½œãƒœã‚¿ãƒ³
> const actionButtons = document.createElement('div');
> actionButtons.style.marginBottom = '10px';
> actionButtons.style.display = 'flex';
> actionButtons.style.gap = '10px';
> actionButtons.style.flexWrap = 'wrap';
> 
> const completeBtn = document.createElement('button');
> completeBtn.textContent = 'âœ… é¸æŠã—ãŸã‚¿ã‚¹ã‚¯ã‚’å®Œäº†';
> completeBtn.style.padding = '8px 16px';
> completeBtn.style.cursor = 'pointer';
> completeBtn.style.flex = '1';
> completeBtn.disabled = true;
> completeBtn.style.opacity = '0.5';
> 
> const deleteBtn = document.createElement('button');
> deleteBtn.textContent = 'ğŸ—‘ï¸ é¸æŠã—ãŸã‚¿ã‚¹ã‚¯ã‚’å‰Šé™¤';
> deleteBtn.style.padding = '8px 16px';
> deleteBtn.style.cursor = 'pointer';
> deleteBtn.style.flex = '1';
> deleteBtn.disabled = true;
> deleteBtn.style.opacity = '0.5';
> 
> const moveDateBtn = document.createElement('button');
> moveDateBtn.textContent = 'ğŸ“… é¸æŠã—ãŸã‚¿ã‚¹ã‚¯ã‚’æ—¥ä»˜ç§»å‹•';
> moveDateBtn.style.padding = '8px 16px';
> moveDateBtn.style.cursor = 'pointer';
> moveDateBtn.style.flex = '1';
> moveDateBtn.disabled = true;
> moveDateBtn.style.opacity = '0.5';
> 
> const updateButtons = () => {
> const count = selectedTasks.size;
> if (count > 0) {
> completeBtn.disabled = false;
> completeBtn.style.opacity = '1';
> deleteBtn.disabled = false;
> deleteBtn.style.opacity = '1';
> moveDateBtn.disabled = false;
> moveDateBtn.style.opacity = '1';
> } else {
> completeBtn.disabled = true;
> completeBtn.style.opacity = '0.5';
> deleteBtn.disabled = true;
> deleteBtn.style.opacity = '0.5';
> moveDateBtn.disabled = true;
> moveDateBtn.style.opacity = '0.5';
> }
> };
> 
> completeBtn.onclick = async () => {
> if (selectedTasks.size === 0) return;
> const selectedIndices = Array.from(selectedTasks).sort((a, b) => b - a);
> const tasksByFile = {};
> selectedIndices.forEach(index => {
> const taskData = allTasks[index];
> if (!tasksByFile[taskData.filePath]) {
> tasksByFile[taskData.filePath] = [];
> }
> tasksByFile[taskData.filePath].push(taskData);
> });
> 
> let successCount = 0;
> for (const [filePath, tasks] of Object.entries(tasksByFile)) {
> try {
> const file = app.vault.getAbstractFileByPath(filePath);
> if (!file) continue;
> let content = await app.vault.read(file);
> let modified = false;
> tasks.forEach(taskData => {
> if (content.includes(taskData.task.text)) {
> content = content.replace(taskData.task.text, taskData.task.text.replace(/^- \[ \]/, '- [x]'));
> modified = true;
> successCount++;
> }
> });
> if (modified) await app.vault.modify(file, content);
> } catch (error) {
> console.error(`ãƒ•ã‚¡ã‚¤ãƒ« ${filePath} ã®å‡¦ç†ã‚¨ãƒ©ãƒ¼:`, error);
> }
> }
> if (successCount > 0) {
> new Notice(`âœ… ${successCount}ä»¶ã®ã‚¿ã‚¹ã‚¯ã‚’å®Œäº†ã—ã¾ã—ãŸ`);
> setTimeout(() => app.commands.executeCommandById('dataview:refresh-views'), 500);
> }
> };
> 
> deleteBtn.onclick = async () => {
> if (selectedTasks.size === 0) return;
> const selectedIndices = Array.from(selectedTasks).sort((a, b) => b - a);
> const tasksByFile = {};
> selectedIndices.forEach(index => {
> const taskData = allTasks[index];
> if (!tasksByFile[taskData.filePath]) {
> tasksByFile[taskData.filePath] = [];
> }
> tasksByFile[taskData.filePath].push(taskData);
> });
> 
> let successCount = 0;
> for (const [filePath, tasks] of Object.entries(tasksByFile)) {
> try {
> const file = app.vault.getAbstractFileByPath(filePath);
> if (!file) continue;
> let content = await app.vault.read(file);
> let modified = false;
> tasks.forEach(taskData => {
> if (content.includes(taskData.task.text)) {
> content = content.replace(taskData.task.text + '\n', '').replace('\n' + taskData.task.text, '').replace(taskData.task.text, '');
> modified = true;
> successCount++;
> }
> });
> if (modified) await app.vault.modify(file, content);
> } catch (error) {
> console.error(`ãƒ•ã‚¡ã‚¤ãƒ« ${filePath} ã®å‡¦ç†ã‚¨ãƒ©ãƒ¼:`, error);
> }
> }
> if (successCount > 0) {
> new Notice(`ğŸ—‘ï¸ ${successCount}ä»¶ã®ã‚¿ã‚¹ã‚¯ã‚’å‰Šé™¤ã—ã¾ã—ãŸ`);
> setTimeout(() => app.commands.executeCommandById('dataview:refresh-views'), 500);
> }
> };
> 
> moveDateBtn.onclick = async () => {
> if (selectedTasks.size === 0) {
> new Notice('âš ï¸ ã‚¿ã‚¹ã‚¯ã‚’é¸æŠã—ã¦ãã ã•ã„');
> return;
> }
> 
> try {
> // QuickAddãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã®ç¢ºèª
> const quickAddPlugin = app.plugins.plugins.quickadd;
> if (!quickAddPlugin || !quickAddPlugin.api) {
> new Notice('âŒ QuickAddãƒ—ãƒ©ã‚°ã‚¤ãƒ³ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
> return;
> }
> const quickAddApi = quickAddPlugin.api;
> 
> // æ˜æ—¥ã®æ—¥ä»˜ã‚’ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã¨ã—ã¦è¨­å®š
> const tomorrow = moment().add(1, 'day').format("YYYY-MM-DD");
> 
> // ç§»å‹•å…ˆã®æ—¥ä»˜ã‚’å…¥åŠ›
> const newDateInput = await quickAddApi.inputPrompt(
> "ç§»å‹•å…ˆã®æ—¥ä»˜ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ (YYYY-MM-DD) - ç©ºç™½ã®å ´åˆã¯æ˜æ—¥",
> tomorrow
> );
> 
> // ã‚­ãƒ£ãƒ³ã‚»ãƒ«ã•ã‚ŒãŸå ´åˆã‚„nullã®å ´åˆã¯å‡¦ç†ã‚’ä¸­æ–­
> if (newDateInput === null || newDateInput === undefined) {
> return;
> }
> 
> // ç©ºç™½ã®å ´åˆã¯æ˜æ—¥ã«è¨­å®š
> const inputDate = newDateInput.trim() || tomorrow;
> 
> // æ—¥ä»˜ã®å¦¥å½“æ€§ãƒã‚§ãƒƒã‚¯
> const newDate = moment(inputDate, "YYYY-MM-DD");
> if (!newDate.isValid()) {
> new Notice('ç„¡åŠ¹ãªæ—¥ä»˜å½¢å¼ã§ã™ã€‚YYYY-MM-DDå½¢å¼ã§å…¥åŠ›ã—ã¦ãã ã•ã„');
> return;
> }
> 
> const newDateStr = newDate.format("YYYY-MM-DD");
> const schedulePath = "03.ãƒ„ã‚§ãƒƒãƒ†ãƒ«ã‚«ã‚¹ãƒ†ãƒ³/030.ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹/ã‚¿ã‚¹ã‚¯ç®¡ç†/ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«";
> 
> // é¸æŠã—ãŸã‚¿ã‚¹ã‚¯ã‚’å‡¦ç†
> const selectedIndices = Array.from(selectedTasks).sort((a, b) => b - a);
> const tasksByFile = {};
> selectedIndices.forEach(index => {
> const taskData = allTasks[index];
> if (!tasksByFile[taskData.filePath]) {
> tasksByFile[taskData.filePath] = [];
> }
> tasksByFile[taskData.filePath].push(taskData);
> });
> 
> let totalSuccess = 0;
> 
> // ç§»å‹•å…ˆã®ãƒ•ã‚¡ã‚¤ãƒ«ã‚’æº–å‚™
> const newFilePath = `${schedulePath}/${newDateStr}.md`;
> let newFile = app.vault.getAbstractFileByPath(newFilePath);
> if (!newFile) {
> newFile = await app.vault.create(newFilePath, `## ä»Šæ—¥ã®ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«\n\n`);
> }
> let newFileContent = await app.vault.read(newFile);
> 
> // å„ãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰ã‚¿ã‚¹ã‚¯ã‚’å‰Šé™¤ã—ã€æ–°ã—ã„ãƒ•ã‚¡ã‚¤ãƒ«ã«è¿½åŠ 
> for (const [filePath, tasks] of Object.entries(tasksByFile)) {
> try {
> const file = app.vault.getAbstractFileByPath(filePath);
> if (!file) continue;
> 
> let content = await app.vault.read(file);
> const lines = content.split('\n');
> const linesToRemove = new Set();
> let modified = false;
> 
> // ã¾ãšã€ã™ã¹ã¦ã®ã‚¿ã‚¹ã‚¯ã‚’æ–°ã—ã„ãƒ•ã‚¡ã‚¤ãƒ«ã«è¿½åŠ 
> for (const taskData of tasks) {
> const originalLine = taskData.task.text;
> const trimmedOriginal = originalLine.trim();
> 
> // ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã‚’æŠ½å‡º
> const projectMatch = trimmedOriginal.match(/ğŸ”—\s*([^\s]+)/);
> const projectName = projectMatch ? projectMatch[1] : null;
> 
> // æ–°ã—ã„æ—¥ä»˜ã§ã‚¿ã‚¹ã‚¯è¡Œã‚’ä½œæˆ
> let updatedTaskLine = originalLine;
> 
> if (newDurationMinutes !== null) {
> updatedTaskLine = applyDuration(updatedTaskLine);
> }
> 
> if (updatedTaskLine.includes('ğŸ“…')) {
> updatedTaskLine = updatedTaskLine.replace(/ğŸ“…\s*\d{4}-\d{2}-\d{2}/, `ğŸ“… ${newDateStr}`);
> } else {
> if (updatedTaskLine.includes('â°')) {
> updatedTaskLine = updatedTaskLine.replace(/(â°\s*\d{4}-\d{2}-\d{2})/, `ğŸ“… ${newDateStr} $1`);
> } else if (updatedTaskLine.includes('ğŸ”—')) {
> updatedTaskLine = updatedTaskLine.replace(/(ğŸ”—\s*[^\s]+)/, `ğŸ“… ${newDateStr} $1`);
> } else {
> updatedTaskLine = updatedTaskLine.trim() + ` ğŸ“… ${newDateStr}`;
> }
> }
> 
> // æ–°ã—ã„ãƒ•ã‚¡ã‚¤ãƒ«ã«è¿½åŠ 
> const trimmedUpdatedLine = updatedTaskLine.trim();
> if (!newFileContent.includes(trimmedUpdatedLine)) {
> newFileContent += trimmedUpdatedLine + '\n';
> totalSuccess++;
> }
> 
> // ã‚¿ã‚¹ã‚¯åã‚’æŠ½å‡º
> const taskNameOnly = trimmedOriginal
> .replace(/^- \[[ x]\]\s*/, '')
> .replace(/\s*â±ï¸\s*\d+/, '')
> .replace(/\s*ğŸ“…\s*\d{4}-\d{2}-\d{2}/, '')
> .replace(/\s*â°\s*\d{4}-\d{2}-\d{2}/, '')
> .replace(/\s*ğŸ”—\s*[^\s]+/, '')
> .replace(/\s*#\w+/g, '')
> .trim();
> 
> // å…ƒã®ãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰å‰Šé™¤
> for (let i = 0; i < lines.length; i++) {
> const line = lines[i];
> const trimmedLine = line.trim();
> 
> if (trimmedLine === trimmedOriginal) {
> linesToRemove.add(i);
> modified = true;
> break;
> }
> 
> const isTaskLine = line.includes('- [') || (taskNameOnly && trimmedLine.includes(taskNameOnly));
> if (!isTaskLine) continue;
> 
> if (taskNameOnly && trimmedLine.includes(taskNameOnly)) {
> const lineTaskName = trimmedLine
> .replace(/^- \[[ x]\]\s*/, '')
> .replace(/\s*â±ï¸\s*\d+/, '')
> .replace(/\s*ğŸ“…\s*\d{4}-\d{2}-\d{2}/, '')
> .replace(/\s*â°\s*\d{4}-\d{2}-\d{2}/, '')
> .replace(/\s*ğŸ”—\s*[^\s]+/, '')
> .replace(/\s*#\w+/g, '')
> .trim();
> 
> if (lineTaskName === taskNameOnly) {
> linesToRemove.add(i);
> modified = true;
> break;
> }
> }
> }
> 
> // ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ã®æ—¥ä»˜ã‚‚æ›´æ–°
> if (projectName) {
> const projectPath = `03.ãƒ„ã‚§ãƒƒãƒ†ãƒ«ã‚«ã‚¹ãƒ†ãƒ³/030.ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹/ã‚¿ã‚¹ã‚¯ç®¡ç†/ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆ/${projectName}.md`;
> const projectFile = app.vault.getAbstractFileByPath(projectPath);
> if (projectFile) {
> try {
> let projectContent = await app.vault.read(projectFile);
> const projectLines = projectContent.split('\n');
> let projectModified = false;
> 
> for (let i = 0; i < projectLines.length; i++) {
> const line = projectLines[i];
> const trimmedLine = line.trim();
> 
> const isTaskLine = line.includes('- [') || (taskNameOnly && trimmedLine.includes(taskNameOnly));
> if (!isTaskLine) continue;
> 
> if (taskNameOnly && trimmedLine.includes(taskNameOnly)) {
> const lineTaskName = trimmedLine
> .replace(/^- \[[ x]\]\s*/, '')
> .replace(/\s*â±ï¸\s*\d+/, '')
> .replace(/\s*ğŸ“…\s*\d{4}-\d{2}-\d{2}/, '')
> .replace(/\s*â°\s*\d{4}-\d{2}-\d{2}/, '')
> .replace(/\s*ğŸ”—\s*[^\s]+/, '')
> .replace(/\s*#\w+/g, '')
> .trim();
> 
> if (lineTaskName === taskNameOnly) {
> if (newDurationMinutes !== null) {
> projectLines[i] = applyDuration(projectLines[i]);
> }
> if (projectLines[i].includes('ğŸ“…')) {
> projectLines[i] = projectLines[i].replace(/ğŸ“…\s*\d{4}-\d{2}-\d{2}/, `ğŸ“… ${newDateStr}`);
> } else {
> projectLines[i] = projectLines[i].trim() + ` ğŸ“… ${newDateStr}`;
> }
> projectModified = true;
> }
> }
> }
> 
> if (projectModified) {
> projectContent = projectLines.join('\n');
> await app.vault.modify(projectFile, projectContent);
> }
> } catch (error) {
> console.error(`ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãƒ•ã‚¡ã‚¤ãƒ« ${projectPath} ã®å‡¦ç†ã‚¨ãƒ©ãƒ¼:`, error);
> }
> }
> }
> }
> 
> // å…ƒã®ãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰å‰Šé™¤
> if (modified) {
> const sortedIndices = Array.from(linesToRemove).sort((a, b) => b - a);
> sortedIndices.forEach(index => {
> lines.splice(index, 1);
> });
> content = lines.join('\n');
> await app.vault.modify(file, content);
> }
> } catch (error) {
> console.error(`ãƒ•ã‚¡ã‚¤ãƒ« ${filePath} ã®å‡¦ç†ã‚¨ãƒ©ãƒ¼:`, error);
> }
> }
> 
> // æ–°ã—ã„ãƒ•ã‚¡ã‚¤ãƒ«ã«ä¿å­˜
> if (totalSuccess > 0) {
> await app.vault.modify(newFile, newFileContent);
> new Notice(`ğŸ“… ${totalSuccess}ä»¶ã®ã‚¿ã‚¹ã‚¯ã‚’${newDateStr}ã«ç§»å‹•ã—ã¾ã—ãŸ`);
> setTimeout(() => {
> app.commands.executeCommandById('dataview:refresh-views');
> }, 500);
> } else {
> new Notice('âš ï¸ ç§»å‹•ã§ããŸã‚¿ã‚¹ã‚¯ãŒã‚ã‚Šã¾ã›ã‚“ã§ã—ãŸ');
> }
> } catch (error) {
> console.error('ã‚¿ã‚¹ã‚¯ç§»å‹•å‡¦ç†ã‚¨ãƒ©ãƒ¼:', error);
> new Notice(`âŒ ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ: ${error.message}`);
> }
> };
> 
> actionButtons.appendChild(completeBtn);
> actionButtons.appendChild(deleteBtn);
> actionButtons.appendChild(moveDateBtn);
> taskListContainer.appendChild(actionButtons);
> 
> // ãƒ†ãƒ¼ãƒ–ãƒ«
> const table = document.createElement('table');
> table.style.width = '100%';
> table.style.borderCollapse = 'collapse';
> table.style.tableLayout = 'auto'; // è‡ªå‹•ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆã§è¤‡æ•°è¡Œã«å¯¾å¿œ
> const thead = document.createElement('thead');
> const headerRow = document.createElement('tr');
> ['', 'æ—¥ä»˜', 'ã‚¿ã‚¹ã‚¯', 'ã‚¸ãƒ£ãƒ³ãƒ«', 'æ™‚é–“', 'çŠ¶æ…‹', 'ãƒªãƒ³ã‚¯'].forEach(header => {
> const th = document.createElement('th');
> th.textContent = header;
> th.style.padding = '8px';
> th.style.textAlign = 'left';
> th.style.borderBottom = '2px solid var(--background-modifier-border)';
> th.style.whiteSpace = 'nowrap'; // ãƒ˜ãƒƒãƒ€ãƒ¼ã¯æ”¹è¡Œã—ãªã„
> headerRow.appendChild(th);
> });
> thead.appendChild(headerRow);
> table.appendChild(thead);
> const tbody = document.createElement('tbody');
> allTasks.forEach((taskData, index) => {
> const row = document.createElement('tr');
> row.style.height = 'auto'; // è¡Œã®é«˜ã•ã‚’è‡ªå‹•èª¿æ•´
> row.style.verticalAlign = 'top'; // ä¸Šæƒãˆ
> 
> const checkboxCell = document.createElement('td');
> checkboxCell.style.verticalAlign = 'top'; // ä¸Šæƒãˆ
> checkboxCell.style.padding = '8px';
> const checkbox = document.createElement('input');
> checkbox.type = 'checkbox';
> checkbox.id = `week-task-${index}`;
> checkbox.style.cursor = 'pointer';
> checkbox.style.marginTop = '4px'; // ãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹ã‚’å°‘ã—ä¸‹ã«é…ç½®
> checkbox.onchange = () => {
> if (checkbox.checked) selectedTasks.add(index);
> else selectedTasks.delete(index);
> updateButtons();
> };
> checkboxCell.appendChild(checkbox);
> row.appendChild(checkboxCell);
> 
> [taskData.dateLabel, taskData.taskName, taskData.genre, taskData.duration, taskData.status].forEach((value, cellIndex) => {
> const cell = document.createElement('td');
> cell.style.padding = '8px';
> cell.style.verticalAlign = 'top'; // ä¸Šæƒãˆ
> cell.style.wordWrap = 'break-word'; // é•·ã„ãƒ†ã‚­ã‚¹ãƒˆã‚’æŠ˜ã‚Šè¿”ã™
> cell.style.wordBreak = 'break-word'; // å˜èªã®é€”ä¸­ã§ã‚‚æŠ˜ã‚Šè¿”ã™
> cell.style.whiteSpace = 'pre-wrap'; // æ”¹è¡Œã‚’ä¿æŒã—ã¤ã¤æŠ˜ã‚Šè¿”ã™
> cell.style.maxWidth = cellIndex === 1 ? '300px' : 'none'; // ã‚¿ã‚¹ã‚¯åã®åˆ—ã¯æœ€å¤§å¹…ã‚’è¨­å®š
> cell.textContent = value;
> row.appendChild(cell);
> });
> 
> // ãƒªãƒ³ã‚¯åˆ—ã‚’è¿½åŠ 
> const linkCell = document.createElement('td');
> linkCell.style.padding = '8px';
> linkCell.style.verticalAlign = 'top';
> const linkPath = `${schedulePath}/${taskData.dateStr}.md`;
> const link = document.createElement('a');
> link.textContent = 'ğŸ“„ é–‹ã';
> link.style.cursor = 'pointer';
> link.style.color = 'var(--link-color)';
> link.style.textDecoration = 'underline';
> link.onclick = async (e) => {
> e.preventDefault();
> const file = app.vault.getAbstractFileByPath(linkPath);
> if (file) {
> await app.workspace.getLeaf().openFile(file);
> } else {
> new Notice(`ãƒ•ã‚¡ã‚¤ãƒ«ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“: ${linkPath}`);
> }
> };
> linkCell.appendChild(link);
> row.appendChild(linkCell);
> 
> tbody.appendChild(row);
> });
> table.appendChild(tbody);
> taskListContainer.appendChild(table);
> // taskListContainerã«è¦ç´ ãŒã‚ã‚‹å ´åˆã®ã¿è¿½åŠ 
> if (taskListContainer.children.length > 0) {
> taskContainer.appendChild(taskListContainer);
> }
> }
> 
> // é€±é–“å®¹é‡ä½¿ç”¨çŠ¶æ³
> const weekMaxMinutes = maxDailyMinutes * workingDaysPerWeek;
> const weekUsagePercent = Math.round((weekTotalMinutes / weekMaxMinutes) * 100);
> const filledBars = Math.max(0, Math.min(20, Math.floor(weekUsagePercent / 5)));
> const emptyBars = Math.max(0, 20 - filledBars);
> const weekUsageBar = "â–ˆ".repeat(filledBars) + "â–‘".repeat(emptyBars);
> dv.paragraph(`\n**é€±é–“å®¹é‡ä½¿ç”¨çŠ¶æ³**: ${weekTotalMinutes}åˆ† / ${weekMaxMinutes}åˆ† (${weekUsagePercent}%)\n${weekUsageBar}`);
> 
> // ã‚¸ãƒ£ãƒ³ãƒ«åˆ¥æ§‹æˆæ¯”
> if (Object.keys(weekGenreBreakdown).length > 0) {
> dv.paragraph("\n**ã‚¸ãƒ£ãƒ³ãƒ«åˆ¥æ§‹æˆæ¯”**:");
> dv.table(
> ["ã‚¸ãƒ£ãƒ³ãƒ«", "æ™‚é–“", "æ§‹æˆæ¯”"],
> Object.entries(weekGenreBreakdown)
> .sort((a, b) => b[1] - a[1])
> .map(([genre, minutes]) => [
> genre,
> `${minutes}åˆ†`,
> `${Math.round((minutes / weekTotalMinutes) * 100)}%`
> ])
> );
> }
> 
> dv.paragraph(`\nğŸ‘‰ [[${schedulePath}/${startOfWeek.format("YYYY-MM-DD")}|é€±ã®è©³ç´°ã‚’è¦‹ã‚‹]]`);
> ```

> [!info]- ğŸ“Š ä»Šé€±ã®æ—¥åˆ¥å®¹é‡çŠ¶æ³
> 
> ```dataviewjs
> const today = moment().startOf('day');
> const schedulePath = "03.ãƒ„ã‚§ãƒƒãƒ†ãƒ«ã‚«ã‚¹ãƒ†ãƒ³/030.ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹/ã‚¿ã‚¹ã‚¯ç®¡ç†/ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«";
> const CONFIG_PATH = "03.ãƒ„ã‚§ãƒƒãƒ†ãƒ«ã‚«ã‚¹ãƒ†ãƒ³/030.ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹/ã‚¿ã‚¹ã‚¯ç®¡ç†/config/settings.json";
> const DEFAULT_MAX_DAILY_MINUTES = 360;
> const DEFAULT_WORKING_DAYS = 5;
> let maxDailyMinutes = DEFAULT_MAX_DAILY_MINUTES;
> let workingDaysPerWeek = DEFAULT_WORKING_DAYS;
> 
> try {
> const configContent = await dv.io.load(CONFIG_PATH);
> if (configContent) {
> const config = JSON.parse(configContent);
> if (Number.isFinite(config.maxDailyMinutes)) {
> maxDailyMinutes = config.maxDailyMinutes;
> }
> if (Number.isFinite(config.workingDaysPerWeek)) {
> workingDaysPerWeek = config.workingDaysPerWeek;
> }
> }
> } catch (error) {
> console.error("è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ã®èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼:", error);
> }
> 
> // ä»Šé€±ã®é–‹å§‹ï¼ˆæœˆæ›œæ—¥ï¼‰ã‚’è¨ˆç®—
> const startOfWeek = moment(today).startOf('isoWeek'); // æœˆæ›œæ—¥
> 
> const dailyCapacity = [];
> 
> // é€±ã®å„æ—¥ã‚’ãƒ«ãƒ¼ãƒ—
> for (let i = 0; i < 7; i++) {
> const date = moment(startOfWeek).add(i, 'days');
> const dateStr = date.format("YYYY-MM-DD");
> const dateLabel = date.format("MM/DD(ddd)");
> const dateFile = dv.page(`${schedulePath}/${dateStr}`);
> 
> let totalMinutes = 0;
> let taskCount = 0;
> 
> if (dateFile) {
> const tasks = dateFile.file.tasks;
> const tasksWithTime = tasks.where(t => {
> const text = t.text;
> return text.includes("â±ï¸");
> }).array();
> 
> tasksWithTime.forEach(task => {
> const timeMatch = task.text.match(/â±ï¸ (\d+)/);
> const duration = timeMatch ? parseInt(timeMatch[1]) : 0;
> totalMinutes += duration;
> taskCount++;
> });
> }
> 
> const usagePercent = Math.round((totalMinutes / maxDailyMinutes) * 100);
> const isToday = date.isSame(today, 'day');
> const isTomorrow = date.isSame(moment(today).add(1, 'day'), 'day');
> const isPast = date.isBefore(today, 'day');
> 
> let statusLabel = "";
> if (isToday) statusLabel = " **ä»Šæ—¥**";
> else if (isTomorrow) statusLabel = " **æ˜æ—¥**";
> else if (isPast) statusLabel = " (éå»)";
> 
> dailyCapacity.push({
> date: dateStr,
> label: dateLabel + statusLabel,
> minutes: totalMinutes,
> percent: usagePercent,
> taskCount: taskCount,
> isToday: isToday,
> isTomorrow: isTomorrow
> });
> }
> 
> // ãƒ†ãƒ¼ãƒ–ãƒ«å½¢å¼ã§è¡¨ç¤º
> dv.table(
> ["æ—¥ä»˜", "ã‚¿ã‚¹ã‚¯æ•°", "ä½¿ç”¨æ™‚é–“", "ä½¿ç”¨ç‡", "çŠ¶æ³"],
> dailyCapacity.map(day => {
> const filledBars = Math.max(0, Math.min(20, Math.floor(day.percent / 5)));
> const emptyBars = Math.max(0, 20 - filledBars);
> const usageBar = "â–ˆ".repeat(filledBars) + "â–‘".repeat(emptyBars);
> let status = "";
> if (day.minutes > maxDailyMinutes) {
> status = "âš ï¸ è¶…é";
> } else if (day.percent >= 90) {
> status = "ğŸŸ¡ é«˜";
> } else if (day.percent >= 50) {
> status = "ğŸŸ¢ ä¸­";
> } else if (day.minutes > 0) {
> status = "âšª ä½";
> } else {
> status = "-";
> }
> 
> return [
> day.label,
> day.taskCount > 0 ? `${day.taskCount}ä»¶` : "-",
> day.minutes > 0 ? `${day.minutes}åˆ†` : "-",
> `${day.percent}% ${usageBar}`,
> status
> ];
> })
> );
> 
> // é€±é–“åˆè¨ˆ
> const weekTotal = dailyCapacity.reduce((sum, day) => sum + day.minutes, 0);
> const weekMax = maxDailyMinutes * workingDaysPerWeek;
> const weekPercent = Math.round((weekTotal / weekMax) * 100);
> dv.paragraph(`\n**é€±é–“åˆè¨ˆ**: ${weekTotal}åˆ† / ${weekMax}åˆ† (${weekPercent}%)`);
> ```

> [!info]- ğŸ“ˆ ã‚¿ã‚¹ã‚¯é€²æ—è¡¨
> 
> ```dataviewjs
> const schedulePath = "03.ãƒ„ã‚§ãƒƒãƒ†ãƒ«ã‚«ã‚¹ãƒ†ãƒ³/030.ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹/ã‚¿ã‚¹ã‚¯ç®¡ç†/ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«";
> const today = moment().startOf('day');
> const startOfWeek = moment(today).startOf('isoWeek');
> const startOfMonth = moment(today).startOf('month');
> 
> // ã‚¸ãƒ£ãƒ³ãƒ«è¨­å®šã‚’èª­ã¿è¾¼ã‚€
> const genreConfigPath = "03.ãƒ„ã‚§ãƒƒãƒ†ãƒ«ã‚«ã‚¹ãƒ†ãƒ³/030.ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹/ã‚¿ã‚¹ã‚¯ç®¡ç†/ã‚¸ãƒ£ãƒ³ãƒ«è¨­å®š.md";
> let genres = ["ãƒ‡ã‚¹ã‚¯ãƒ¯ãƒ¼ã‚¯", "å£²å ´ä½œæ¥­", "é¡§å®¢å¯¾å¿œ", "å®šå‹ä½œæ¥­", "å­¦ç¿’", "å¥åº·", "è¶£å‘³", "ãã®ä»–ãƒ—ãƒ©ã‚¤ãƒ™ãƒ¼ãƒˆ"]; // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ
> try {
> const genreConfigContent = await dv.io.load(genreConfigPath);
> if (genreConfigContent) {
> const genreMatch = genreConfigContent.match(/const TASK_GENRES = \[([\s\S]*?)\];/);
> if (genreMatch) {
> genres = genreMatch[1]
> .split(',')
> .map(g => g.trim().replace(/^["']|["']$/g, ''))
> .filter(g => g);
> }
> }
> } catch (error) {
> console.error("ã‚¸ãƒ£ãƒ³ãƒ«è¨­å®šã®èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼:", error);
> }
> 
> // é€²æ—ãƒ‡ãƒ¼ã‚¿ã‚’åé›†
> let weekTasks = { total: 0, completed: 0, totalMinutes: 0, completedMinutes: 0 };
> let monthTasks = { total: 0, completed: 0, totalMinutes: 0, completedMinutes: 0 };
> const genreProgress = {};
> 
> // ä»Šé€±ã®ã‚¿ã‚¹ã‚¯
> for (let i = 0; i < 7; i++) {
> const date = moment(startOfWeek).add(i, 'days');
> const dateStr = date.format("YYYY-MM-DD");
> const dateFile = dv.page(`${schedulePath}/${dateStr}`);
> 
> if (dateFile) {
> const tasks = dateFile.file.tasks;
> const tasksWithTime = tasks.where(t => t.text.includes("â±ï¸")).array();
> 
> tasksWithTime.forEach(task => {
> const timeMatch = task.text.match(/â±ï¸ (\d+)/);
> const duration = timeMatch ? parseInt(timeMatch[1]) : 0;
> 
> weekTasks.total++;
> weekTasks.totalMinutes += duration;
> 
> if (task.completed) {
> weekTasks.completed++;
> weekTasks.completedMinutes += duration;
> }
> 
> // ã‚¸ãƒ£ãƒ³ãƒ«åˆ¥é€²æ—
> for (const genre of genres) {
> if (task.text.includes(`#${genre}`)) {
> if (!genreProgress[genre]) {
> genreProgress[genre] = { total: 0, completed: 0, totalMinutes: 0, completedMinutes: 0 };
> }
> genreProgress[genre].total++;
> genreProgress[genre].totalMinutes += duration;
> if (task.completed) {
> genreProgress[genre].completed++;
> genreProgress[genre].completedMinutes += duration;
> }
> break;
> }
> }
> });
> }
> }
> 
> // ä»Šæœˆã®ã‚¿ã‚¹ã‚¯
> const daysInMonth = today.daysInMonth();
> for (let i = 0; i < daysInMonth; i++) {
> const date = moment(startOfMonth).add(i, 'days');
> const dateStr = date.format("YYYY-MM-DD");
> const dateFile = dv.page(`${schedulePath}/${dateStr}`);
> 
> if (dateFile) {
> const tasks = dateFile.file.tasks;
> const tasksWithTime = tasks.where(t => t.text.includes("â±ï¸")).array();
> 
> tasksWithTime.forEach(task => {
> const timeMatch = task.text.match(/â±ï¸ (\d+)/);
> const duration = timeMatch ? parseInt(timeMatch[1]) : 0;
> 
> monthTasks.total++;
> monthTasks.totalMinutes += duration;
> 
> if (task.completed) {
> monthTasks.completed++;
> monthTasks.completedMinutes += duration;
> }
> });
> }
> }
> 
> // ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆé€²æ—
> const projectPath = "03.ãƒ„ã‚§ãƒƒãƒ†ãƒ«ã‚«ã‚¹ãƒ†ãƒ³/030.ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹/ã‚¿ã‚¹ã‚¯ç®¡ç†/ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆ";
> const projectFiles = dv.pages(`"${projectPath}"`)
> .where(p => p.file.name !== "README" && p.file.name !== "ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆ");
> 
> console.log(`ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãƒ•ã‚¡ã‚¤ãƒ«æ•°: ${projectFiles.length}`);
> projectFiles.forEach(p => console.log(`ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆ: ${p.file.name} (${p.file.path})`));
> 
> const projectProgress = [];
> for (const project of projectFiles) {
> try {
> const content = await dv.io.load(project.file.path);
> if (!content) {
> console.log(`ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆ ${project.file.name}: ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ãŒç©º`);
> continue;
> }
> 
> // DataviewJSãƒ–ãƒ­ãƒƒã‚¯ã‚’é™¤å¤–
>     const cleanContent = content.replace(/```dataviewjs[\s\S]*?```/g, '');
> 
> // ã‚µãƒ–ã‚¿ã‚¹ã‚¯ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã‚’æŠ½å‡ºï¼ˆã‚ˆã‚Šç¢ºå®Ÿãªæ–¹æ³•ï¼‰
> const subtaskStartIndex = cleanContent.indexOf('## ã‚µãƒ–ã‚¿ã‚¹ã‚¯');
> if (subtaskStartIndex === -1) {
> console.log(`ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆ ${project.file.name}: ã‚µãƒ–ã‚¿ã‚¹ã‚¯ã‚»ã‚¯ã‚·ãƒ§ãƒ³ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“`);
> continue;
> }
> 
> // ã‚µãƒ–ã‚¿ã‚¹ã‚¯ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã®é–‹å§‹ä½ç½®ã‹ã‚‰ã€æ¬¡ã® ## ã‚»ã‚¯ã‚·ãƒ§ãƒ³ï¼ˆãƒ¡ãƒ¢ï¼‰ã¾ã§ã®é–“ã‚’å–å¾—
> const afterSubtask = cleanContent.substring(subtaskStartIndex);
> const nextSectionIndex = afterSubtask.indexOf('\n## ');
> const subtaskSection = nextSectionIndex !== -1 
> ? afterSubtask.substring(0, nextSectionIndex)
> : afterSubtask;
> 
> console.log(`ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆ ${project.file.name}: ã‚µãƒ–ã‚¿ã‚¹ã‚¯ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã®é•·ã•: ${subtaskSection.length}`);
> console.log(`ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆ ${project.file.name}: ã‚µãƒ–ã‚¿ã‚¹ã‚¯ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã®æœ€åˆã®300æ–‡å­—: ${subtaskSection.substring(0, 300)}`);
> 
> // ã‚¿ã‚¹ã‚¯è¡Œã‚’æŠ½å‡ºï¼ˆã‚ˆã‚Šç¢ºå®Ÿãªæ–¹æ³•ï¼‰
> const allLines = subtaskSection.split('\n');
> console.log(`ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆ ${project.file.name}: ç·è¡Œæ•°: ${allLines.length}`);
> 
> const taskLines = allLines.filter(line => {
> const trimmed = line.trim();
> // - [ ] ã¾ãŸã¯ - [x] ã§å§‹ã¾ã‚‹è¡Œã‚’ã‚¿ã‚¹ã‚¯ã¨ã—ã¦èªè­˜
> const isTask = trimmed.startsWith('- [') && (trimmed.includes('[ ]') || trimmed.includes('[x]'));
> if (isTask) {
> console.log(`ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆ ${project.file.name}: ã‚¿ã‚¹ã‚¯è¡Œã‚’ç™ºè¦‹: ${trimmed.substring(0, 60)}`);
> }
> return isTask;
> });
> 
> console.log(`ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆ ${project.file.name}: ã‚¿ã‚¹ã‚¯è¡Œæ•°: ${taskLines.length}`);
> 
> let total = 0;
> let completed = 0;
> 
> taskLines.forEach(line => {
> const trimmed = line.trim();
> if (trimmed.startsWith('- [')) {
> total++;
> if (trimmed.includes('[x]')) {
> completed++;
> }
> }
> });
> 
> const progressPercent = total > 0 ? Math.round((completed / total) * 100) : 0;
> const projectName = project.file.name.replace('.md', '');
> 
> projectProgress.push({
> name: projectName,
> completed: completed,
> total: total,
> percent: progressPercent
> });
> } catch (error) {
> console.error(`ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆ ${project.file.name} ã®èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼:`, error);
> }
> }
> 
> // é€²æ—è¡¨ã‚’è¡¨ç¤º
> dv.paragraph("**ğŸ“Š é€±é–“é€²æ—**");
> const weekTaskPercent = weekTasks.total > 0 ? Math.round((weekTasks.completed / weekTasks.total) * 100) : 0;
> const weekMinutesPercent = weekTasks.totalMinutes > 0 ? Math.round((weekTasks.completedMinutes / weekTasks.totalMinutes) * 100) : 0;
> 
> const weekTaskFilled = Math.max(0, Math.min(20, Math.floor(weekTaskPercent / 5)));
> const weekTaskBar = "â–ˆ".repeat(weekTaskFilled) + "â–‘".repeat(20 - weekTaskFilled);
> const weekMinutesFilled = Math.max(0, Math.min(20, Math.floor(weekMinutesPercent / 5)));
> const weekMinutesBar = "â–ˆ".repeat(weekMinutesFilled) + "â–‘".repeat(20 - weekMinutesFilled);
> 
> dv.paragraph(`ã‚¿ã‚¹ã‚¯å®Œäº†ç‡: ${weekTasks.completed}/${weekTasks.total} (${weekTaskPercent}%)\n${weekTaskBar}`);
> dv.paragraph(`æ™‚é–“å®Œäº†ç‡: ${weekTasks.completedMinutes}åˆ†/${weekTasks.totalMinutes}åˆ† (${weekMinutesPercent}%)\n${weekMinutesBar}`);
> 
> dv.paragraph("\n**ğŸ“Š æœˆé–“é€²æ—**");
> const monthTaskPercent = monthTasks.total > 0 ? Math.round((monthTasks.completed / monthTasks.total) * 100) : 0;
> const monthMinutesPercent = monthTasks.totalMinutes > 0 ? Math.round((monthTasks.completedMinutes / monthTasks.totalMinutes) * 100) : 0;
> 
> const monthTaskFilled = Math.max(0, Math.min(20, Math.floor(monthTaskPercent / 5)));
> const monthTaskBar = "â–ˆ".repeat(monthTaskFilled) + "â–‘".repeat(20 - monthTaskFilled);
> const monthMinutesFilled = Math.max(0, Math.min(20, Math.floor(monthMinutesPercent / 5)));
> const monthMinutesBar = "â–ˆ".repeat(monthMinutesFilled) + "â–‘".repeat(20 - monthMinutesFilled);
> 
> dv.paragraph(`ã‚¿ã‚¹ã‚¯å®Œäº†ç‡: ${monthTasks.completed}/${monthTasks.total} (${monthTaskPercent}%)\n${monthTaskBar}`);
> dv.paragraph(`æ™‚é–“å®Œäº†ç‡: ${monthTasks.completedMinutes}åˆ†/${monthTasks.totalMinutes}åˆ† (${monthMinutesPercent}%)\n${monthMinutesBar}`);
> 
> // ã‚¸ãƒ£ãƒ³ãƒ«åˆ¥é€²æ—
> if (Object.keys(genreProgress).length > 0) {
> dv.paragraph("\n**ğŸ“Š ã‚¸ãƒ£ãƒ³ãƒ«åˆ¥é€²æ—ï¼ˆä»Šé€±ï¼‰**");
> const genreTableData = [];
> 
> Object.entries(genreProgress)
> .sort((a, b) => b[1].total - a[1].total)
> .forEach(([genre, data]) => {
> const taskPercent = data.total > 0 ? Math.round((data.completed / data.total) * 100) : 0;
> const minutesPercent = data.totalMinutes > 0 ? Math.round((data.completedMinutes / data.totalMinutes) * 100) : 0;
> genreTableData.push([
> genre,
> `${data.completed}/${data.total}`,
> `${taskPercent}%`,
> `${data.completedMinutes}åˆ†/${data.totalMinutes}åˆ†`,
> `${minutesPercent}%`
> ]);
> });
> 
> if (genreTableData.length > 0) {
> dv.table(
> ["ã‚¸ãƒ£ãƒ³ãƒ«", "ã‚¿ã‚¹ã‚¯å®Œäº†", "å®Œäº†ç‡", "æ™‚é–“å®Œäº†", "æ™‚é–“å®Œäº†ç‡"],
> genreTableData
> );
> }
> }
> 
> // ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆé€²æ—
> if (projectProgress.length > 0) {
> dv.paragraph("\n**ğŸ“ ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆé€²æ—**");
> const projectTableData = projectProgress.map(p => {
> const filled = Math.max(0, Math.min(20, Math.floor(p.percent / 5)));
> const bar = "â–ˆ".repeat(filled) + "â–‘".repeat(20 - filled);
> return [
> p.name,
> `${p.completed}/${p.total}`,
> `${p.percent}%`,
> bar
> ];
> });
> 
> dv.table(
> ["ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆ", "å®Œäº†", "é€²æ—ç‡", "é€²æ—ãƒãƒ¼"],
> projectTableData
> );
> }
> ```
> 
---

> [!info] ğŸ’­ æœ€è¿‘ã®Thinoï¼ˆç›´è¿‘10ä»¶ï¼‰
> 
> ```dataviewjs
> const allFiles = dv.pages('"092.Daily"');
> const today = moment();
> const sevenDaysAgo = moment(today).subtract(7, 'days');
> 
> // ãƒ•ã‚¡ã‚¤ãƒ«åã‹ã‚‰æ—¥ä»˜ã‚’æŠ½å‡ºã—ã¦ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°
> const files = allFiles
> .where(p => {
> const dateMatch = p.file.name.match(/^(\d{4}-\d{2}-\d{2})/);
> if (!dateMatch) return false;
> const fileDate = moment(dateMatch[1]);
> return fileDate.isSameOrAfter(sevenDaysAgo, 'day') && fileDate.isSameOrBefore(today, 'day');
> })
> .sort(p => p.file.name, 'desc');
> 
> const maxDisplay = 10;
> const maxLength = 140;
> const minLength = 1; // çŸ­ã„ãƒ¡ãƒ¢ï¼ˆéŸ“å›½èªãªã©1-2æ–‡å­—ï¼‰ã‚‚è¡¨ç¤º
> const displayedMemos = new Set();
> const memoList = [];
> 
> for (let file of files) {
> try {
> const content = await dv.io.load(file.file.path);
> if (!content) continue;
> 
> // Thinoã‚»ã‚¯ã‚·ãƒ§ãƒ³ã‚’æŠ½å‡ºï¼ˆæ”¹è¡Œã‚³ãƒ¼ãƒ‰ã«æŸ”è»Ÿã«å¯¾å¿œï¼‰
> const thinoMatch = content.match(/##\s+Thino\s*\n([\s\S]*?)(?=\n##\s+|\n---|\z)/);
> if (!thinoMatch) continue;
> 
> const thinoSection = thinoMatch[1];
> const lines = thinoSection.split(/\r?\n/);
> 
> for (let i = 0; i < lines.length; i++) {
> const line = lines[i];
> const match = line.match(/^-\s+(\d{2}:\d{2})?\s*(.*)$/);
> if (!match) continue;
> 
> const time = match[1] || '';
> let memo = match[2].trim();
> 
> // ç©ºã®ãƒ¡ãƒ¢ã¯ã‚¹ã‚­ãƒƒãƒ—
> if (!memo) continue;
> 
> // æ¬¡ã®è¡ŒãŒã‚¤ãƒ³ãƒ‡ãƒ³ãƒˆã•ã‚Œã¦ã„ã‚‹å ´åˆã¯ç¶šãã®å†…å®¹ã¨ã—ã¦è¿½åŠ 
> let j = i + 1;
> while (j < lines.length && (lines[j].startsWith('\t') || lines[j].startsWith('  ') || lines[j].trim() === '')) {
> if (lines[j].trim() !== '') memo += ' ' + lines[j].trim();
> j++;
> }
> 
> // é•·ã™ãã‚‹ãƒ¡ãƒ¢ã¯é™¤å¤–ï¼ˆ140æ–‡å­—ä»¥ä¸Šï¼‰
> if (memo.length >= maxLength) continue;
> 
> // çŸ­ã™ãã‚‹ãƒ¡ãƒ¢ã‚‚é™¤å¤–ï¼ˆ1æ–‡å­—æœªæº€ã€ãŸã ã—ç©ºã§ãªã„ã“ã¨ã¯ä¸Šã§ãƒã‚§ãƒƒã‚¯æ¸ˆã¿ï¼‰
> if (memo.length < minLength) continue;
> 
> // é‡è¤‡ãƒã‚§ãƒƒã‚¯ï¼ˆæœ€åˆã®50æ–‡å­—ã§åˆ¤å®šã€çŸ­ã„ãƒ¡ãƒ¢ã¯å…¨ä½“ã§åˆ¤å®šï¼‰
> const memoKey = memo.length > 50 ? memo.substring(0, 50) : memo;
> if (displayedMemos.has(memoKey)) continue;
> displayedMemos.add(memoKey);
> 
> // ãƒ•ã‚¡ã‚¤ãƒ«åã‹ã‚‰æ—¥ä»˜éƒ¨åˆ†ã‚’æŠ½å‡º
> const dateMatch = file.file.name.match(/^(\d{4}-\d{2}-\d{2})/);
> const dateStr = dateMatch ? dateMatch[1] : file.file.name;
> const timeStr = time || '00:00';
> 
> memoList.push({ 
> date: dateStr, 
> time, 
> memo: memo, 
> sortKey: `${dateStr}T${timeStr}` 
> });
> }
> } catch (error) {
> console.error(`Error processing ${file.file.path}:`, error);
> }
> }
> 
> // ã‚½ãƒ¼ãƒˆï¼ˆæ–°ã—ã„é †ï¼‰
> memoList.sort((a, b) => {
> if (b.sortKey > a.sortKey) return 1;
> if (b.sortKey < a.sortKey) return -1;
> return 0;
> });
> 
> const displayCount = Math.min(maxDisplay, memoList.length);
> if (displayCount === 0) {
> dv.paragraph("_æœ€è¿‘ã®Thinoãƒ¡ãƒ¢ãŒã‚ã‚Šã¾ã›ã‚“_");
> } else {
> for (let i = 0; i < displayCount; i++) {
> const item = memoList[i];
> const memoDisplay = item.memo.length >= maxLength ? item.memo.substring(0, maxLength - 3) + '...' : item.memo;
> dv.paragraph(`**${item.date}** ${item.time ? `\`${item.time}\`` : ''} ${memoDisplay}`);
> }
> dv.paragraph(`\n_${displayCount}ä»¶ã‚’è¡¨ç¤ºï¼ˆ140æ–‡å­—ä»¥ä¸Šã¯é™¤å¤–ã€çŸ­ã„ãƒ¡ãƒ¢ã‚‚è¡¨ç¤ºï¼‰_`);
> }
> ```

> [!info]- ğŸ“š èªå­¦å­¦ç¿’ï¼ˆæœ€è¿‘ã®å˜èªï¼‰
> 
> ```dataview
> TABLE WITHOUT ID file.link as "å˜èªãƒªã‚¹ãƒˆ"
> FROM "04.èªå­¦"
> WHERE file.name != "00.èªå­¦å­¦ç¿’ç·åˆ"
> SORT file.mtime DESC
> LIMIT 5
> ```
 
> [!info]- ğŸ“¥ INBOX
> 
> ```dataview
> LIST
> FROM "03.ãƒ„ã‚§ãƒƒãƒ†ãƒ«ã‚«ã‚¹ãƒ†ãƒ³/031.INBOX"
> SORT file.ctime DESC
> LIMIT 5
> ```

> [!info]- ğŸ½ å¤•é£Ÿãƒ¡ãƒ‹ãƒ¥ãƒ¼ï¼ˆãƒã‚§ãƒƒã‚¯å¯èƒ½ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼ï¼‰
> 
> ```dataviewjs
> const planPath = "03.ãƒ„ã‚§ãƒƒãƒ†ãƒ«ã‚«ã‚¹ãƒ†ãƒ³/030.ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹/é£Ÿæãƒ»æ—¥ç”¨å“ç®¡ç†/å¤•é£Ÿãƒ¡ãƒ‹ãƒ¥ãƒ¼è¨ˆç”».md";
> try {
>   const raw = await dv.io.load(planPath);
>   if (!raw) { dv.paragraph("_è¨ˆç”»ãƒ•ã‚¡ã‚¤ãƒ«ãŒã‚ã‚Šã¾ã›ã‚“_" ); return; }
>   const dataMatch = raw.match(/##\s*ãƒ‡ãƒ¼ã‚¿[^\n]*\r?\n([\s\S]*?)(?=\r?\n##\s+|\r?\n---|$)/);
>   if (!dataMatch) { dv.paragraph("_ãƒ‡ãƒ¼ã‚¿ã‚»ã‚¯ã‚·ãƒ§ãƒ³ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“_"); return; }
>   const dataBlock = dataMatch[1];
>   const dataLines = dataBlock.split(/\r?\n/);
>   const lineMap = new Map();
>   const menuMap = new Map();
>   dataLines.forEach(l => {
>     const m = l.trim().replace(/^-+\s*/, '').match(/^(\d{4}-\d{2}-\d{2})\s*:\s*(.+)$/);
>     if (m) { lineMap.set(m[1], l); menuMap.set(m[1], m[2].trim()); }
>   });
> 
>   // åŠè‡ªå‹•ãƒœã‚¿ãƒ³ï¼ˆæœªæ¥ã®æœªè¡¨è¨˜ã«ï¼ˆæœªå®Ÿæ–½ï¼‰ä»˜ä¸ï¼‰
>   const btnWrap = dv.container.createDiv();
>   const semiBtn = btnWrap.createEl('button', { text: 'ğŸ”„ åŠè‡ªå‹•: æœªæ¥ã®æœªè¡¨è¨˜ã«ï¼ˆæœªå®Ÿæ–½ï¼‰ä»˜ä¸' });
>   semiBtn.style.padding = '6px 12px';
>   semiBtn.style.marginBottom = '8px';
>   semiBtn.onclick = async () => {
>     try {
>       const file = app.vault.getAbstractFileByPath(planPath);
>       if (!file) { new Notice('âŒ è¨ˆç”»ãƒ•ã‚¡ã‚¤ãƒ«ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“'); return; }
>       let cur = await app.vault.read(file);
>       const m2 = cur.match(/##\s*ãƒ‡ãƒ¼ã‚¿[^\n]*\r?\n([\s\S]*?)(?=\r?\n##\s+|\r?\n---|$)/);
>       if (!m2) { new Notice('âŒ ãƒ‡ãƒ¼ã‚¿ã‚»ã‚¯ã‚·ãƒ§ãƒ³ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“'); return; }
>       const block = m2[1];
>       const lines = block.split(/\r?\n/);
>       const today = moment().startOf('day');
>       let changed = false;
>       for (let i = 0; i < lines.length; i++) {
>         const mm = lines[i].trim().replace(/^-+\s*/, '').match(/^(\d{4}-\d{2}-\d{2})\s*:\s*(.+)$/);
>         if (!mm) continue;
>         const d = moment(mm[1], 'YYYY-MM-DD');
>         const menu = mm[2];
>         const hasStatus = menu.includes('ï¼ˆæ¸ˆï¼‰') || menu.includes('ï¼ˆæœªå®Ÿæ–½ï¼‰');
>         if (!hasStatus && d.isSameOrAfter(today, 'day')) { lines[i] = lines[i] + 'ï¼ˆæœªå®Ÿæ–½ï¼‰'; changed = true; }
>       }
>       if (changed) {
>         const newBlock = lines.join('\n');
>         const updated = cur.replace(block, newBlock);
>         await app.vault.modify(file, updated);
>         new Notice('âœ… åŠè‡ªå‹•æ›´æ–°ã‚’é©ç”¨ã—ã¾ã—ãŸ', 2000);
>         setTimeout(() => app.commands.executeCommandById('dataview:refresh-views'), 300);
>       } else {
>         new Notice('â„¹ï¸ ä»˜ä¸å¯¾è±¡ãªã—ï¼ˆå¤‰æ›´ãªã—ï¼‰', 2000);
>       }
>     } catch (e) {
>       console.error(e);
>       new Notice('âŒ åŠè‡ªå‹•æ›´æ–°ã«å¤±æ•—: ' + e.message);
>     }
>   };
> 
>   // ä»Šé€±æœˆæ›œèµ·ç‚¹ã®2é€±é–“ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼ï¼ˆãƒã‚§ãƒƒã‚¯å¯ï¼‰
>   const today = moment().startOf('day');
>   const start = moment(today).startOf('week').add(1, 'day');
>   if (start.day() !== 1) start.subtract((start.day()+6)%7, 'day');
>   const days = ['æœˆ','ç«','æ°´','æœ¨','é‡‘','åœŸ','æ—¥'];
>   const root = document.createElement('div');
>   root.style.overflow = 'auto';
>   const table = document.createElement('table');
>   table.style.width = '100%';
>   table.style.borderCollapse = 'collapse';
>   const thead = document.createElement('thead');
>   const trh = document.createElement('tr');
>   days.forEach(d => {
>     const th = document.createElement('th');
>     th.textContent = d;
>     th.style.borderBottom = '1px solid var(--background-modifier-border)';
>     th.style.padding = '6px';
>     th.style.textAlign = 'left';
>     trh.appendChild(th);
>   });
>   thead.appendChild(trh);
>   table.appendChild(thead);
>   const tbody = document.createElement('tbody');
> 
>   const replaceOne = (full, oldLine, newLine) => {
>     if (oldLine === newLine) return full;
>     const esc = oldLine.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
>     return full.replace(new RegExp(esc), newLine);
>   };
>   const toggleLine = (line, done) => {
>     const without = line.replace('ï¼ˆæ¸ˆï¼‰','').replace('ï¼ˆæœªå®Ÿæ–½ï¼‰','').trimEnd();
>     return done ? (without + 'ï¼ˆæ¸ˆï¼‰') : (without + 'ï¼ˆæœªå®Ÿæ–½ï¼‰');
>   };
> 
>   let cursor = moment(start);
>   for (let week = 0; week < 2; week++) {
>     const tr = document.createElement('tr');
>     for (let i = 0; i < 7; i++) {
>       const key = cursor.format('YYYY-MM-DD');
>       const isToday = cursor.isSame(today, 'day');
>       const td = document.createElement('td');
>       td.style.verticalAlign = 'top';
>       td.style.padding = '6px';
>       td.style.borderBottom = '1px dashed var(--background-modifier-border)';
>       const header = document.createElement('div');
>       header.style.display = 'flex';
>       header.style.justifyContent = 'space-between';
>       header.style.alignItems = 'center';
>       header.style.marginBottom = '4px';
>       if (isToday) { header.style.fontWeight = '600'; header.style.color = 'var(--text-accent)'; }
>       const dateSpan = document.createElement('span');
>       dateSpan.textContent = cursor.format('M/D');
>       header.appendChild(dateSpan);
>       if (isToday) { const tag = document.createElement('span'); tag.textContent = 'ä»Šæ—¥'; tag.style.fontSize = '0.85em'; header.appendChild(tag); }
>       td.appendChild(header);
> 
>       const line = lineMap.get(key);
>       const menuText = menuMap.get(key) || 'æœªè¨­å®š';
>       // è¤‡æ•°ãƒ¡ãƒ‹ãƒ¥ãƒ¼å¯¾å¿œ
>       const SEP = /\s*[ã€,]\s*/;
>       const parseItems = (text) => {
>         let global = null;
>         if (/(ï¼ˆæ¸ˆï¼‰|ï¼ˆæœªå®Ÿæ–½ï¼‰)\s*$/.test(text)) {
>           if (/ï¼ˆæ¸ˆï¼‰\s*$/.test(text)) global = 'æ¸ˆ';
>           else if (/ï¼ˆæœªå®Ÿæ–½ï¼‰\s*$/.test(text)) global = 'æœªå®Ÿæ–½';
>           text = text.replace(/(ï¼ˆæ¸ˆï¼‰|ï¼ˆæœªå®Ÿæ–½ï¼‰)\s*$/, '');
>         }
>         const parts = text.split(SEP).filter(Boolean);
>         return parts.map(p => {
>           let done = null;
>           if (/ï¼ˆæ¸ˆï¼‰$/.test(p)) { done = true; p = p.replace(/ï¼ˆæ¸ˆï¼‰$/, ''); }
>           else if (/ï¼ˆæœªå®Ÿæ–½ï¼‰$/.test(p)) { done = false; p = p.replace(/ï¼ˆæœªå®Ÿæ–½ï¼‰$/, ''); }
>           if (done === null) done = (global === 'æ¸ˆ') ? true : (global === 'æœªå®Ÿæ–½' ? false : false);
>           return { name: p.trim(), done };
>         });
>       };
>       const serializeItems = (dateStr, items) => {
>         const body = items.map(it => `${it.name}${it.done ? 'ï¼ˆæ¸ˆï¼‰' : 'ï¼ˆæœªå®Ÿæ–½ï¼‰'}`).join(', ');
>         return `- ${dateStr}: ${body}`;
>       };
>       const items = parseItems(menuText);
>       if (items.length === 0) {
>         const label = document.createElement('div');
>         label.style.whiteSpace = 'pre-wrap';
>         label.textContent = menuText.replace('ï¼ˆæ¸ˆï¼‰','').replace('ï¼ˆæœªå®Ÿæ–½ï¼‰','');
>         td.appendChild(label);
>       } else {
>         items.forEach((itItem, itemIdx) => {
>           const row = document.createElement('div');
>           row.style.display = 'flex';
>           row.style.gap = '6px';
>           row.style.alignItems = 'center';
>           const cb = document.createElement('input'); cb.type = 'checkbox'; cb.checked = itItem.done; cb.style.cursor = 'pointer';
>           const label = document.createElement('div'); label.style.whiteSpace = 'pre-wrap'; label.textContent = itItem.name;
>           cb.onchange = async () => {
>             if (!line) { new Notice('âš ï¸ ã“ã®æ—¥ã®è¡ŒãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“'); cb.checked = !cb.checked; return; }
>             try {
>               const file = app.vault.getAbstractFileByPath(planPath);
>               if (!file) { new Notice('âŒ è¨ˆç”»ãƒ•ã‚¡ã‚¤ãƒ«ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“'); cb.checked = !cb.checked; return; }
>               let cur = await app.vault.read(file);
>               const m2 = cur.match(/##\s*ãƒ‡ãƒ¼ã‚¿[^\n]*\r?\n([\s\S]*?)(?=\r?\n##\s+|\r?\n---|$)/);
>               if (!m2) { new Notice('âŒ ãƒ‡ãƒ¼ã‚¿ã‚»ã‚¯ã‚·ãƒ§ãƒ³ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“'); cb.checked = !cb.checked; return; }
>               const block = m2[1];
>               const lines = block.split(/\r?\n/);
>               const idx = lines.findIndex(l => l.includes(key + ':'));
>               if (idx === -1) { new Notice('âš ï¸ å¯¾è±¡è¡ŒãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“'); cb.checked = !cb.checked; return; }
>               const oldLine = lines[idx];
>               const mm = oldLine.replace(/^-+\s*/, '').match(/^(\d{4}-\d{2}-\d{2})\s*:\s*(.+)$/);
>               if (!mm) { new Notice('âš ï¸ è¡Œè§£æã«å¤±æ•—'); cb.checked = !cb.checked; return; }
>               const currentItems = parseItems(mm[2]);
>               if (itemIdx >= currentItems.length) { new Notice('âš ï¸ ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ä¸æ•´åˆ'); cb.checked = !cb.checked; return; }
>               currentItems[itemIdx].done = cb.checked;
>               const newLine = serializeItems(key, currentItems);
>               const updated = replaceOne(cur, oldLine, newLine);
>               await app.vault.modify(file, updated);
>               new Notice(cb.checked ? `âœ… ã€Œ${currentItems[itemIdx].name}ã€ã‚’æ¸ˆã«æ›´æ–°` : `â†©ï¸ ã€Œ${currentItems[itemIdx].name}ã€ã‚’æœªå®Ÿæ–½ã«æˆ»ã—ã¾ã—ãŸ`, 1600);
>               setTimeout(() => app.commands.executeCommandById('dataview:refresh-views'), 300);
>             } catch (e) {
>               console.error(e);
>               new Notice('âŒ æ›´æ–°ã«å¤±æ•—: ' + e.message);
>               cb.checked = !cb.checked;
>             }
>           };
>           row.appendChild(cb); row.appendChild(label); td.appendChild(row);
>         });
>       }
>       tr.appendChild(td);
>       cursor.add(1, 'day');
>     }
>     tbody.appendChild(tr);
>   }
>   table.appendChild(tbody);
>   root.appendChild(table);
>   const linkDiv = document.createElement('div'); linkDiv.style.marginTop = '6px';
>   const a = document.createElement('a'); a.className = 'internal-link'; a.href = planPath; a.textContent = 'ç·¨é›†';
>   linkDiv.appendChild(document.createTextNode('ğŸ‘‰ ')); linkDiv.appendChild(a); root.appendChild(linkDiv);
>   dv.container.appendChild(root);
> } catch (e) { dv.paragraph('_èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼_'); }
> ```
> 
> #### ğŸ´ é£Ÿã¹ãŸã„ã‚‚ã®ï¼ˆå€™è£œï¼‰
> ```dataviewjs
> try {
>   const path = "03.ãƒ„ã‚§ãƒƒãƒ†ãƒ«ã‚«ã‚¹ãƒ†ãƒ³/032.PERMANENT/05.06.é£Ÿã¹ãŸã„ã‚‚ã®ãƒªã‚¹ãƒˆ.md";
>   const raw = await dv.io.load(path);
>   const items = (raw.match(/^\- \[ \] .+$/gm) || []).slice(0, 10);
>   if (items.length === 0) dv.paragraph('_å€™è£œã¯ã‚ã‚Šã¾ã›ã‚“_');
>   else items.forEach(l => dv.paragraph(l.replace(/^\- \[ \] /, '- ')));
>   dv.paragraph(`\nğŸ‘‰ [[${path}|ç·¨é›†]]`);
> } catch { dv.paragraph('_èª­è¾¼ã‚¨ãƒ©ãƒ¼_'); }
> ```
> 
> ğŸ‘‰ [[03.ãƒ„ã‚§ãƒƒãƒ†ãƒ«ã‚«ã‚¹ãƒ†ãƒ³/030.ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹/é£Ÿæãƒ»æ—¥ç”¨å“ç®¡ç†/_202511071530_è²·ã„ç‰©ãƒªã‚¹ãƒˆ|è²·ã„ç‰©ãƒªã‚¹ãƒˆã‚’é–‹ã]]

> [!info]- ğŸ’¡ ä»Šæ—¥ã®ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ãƒãƒ¼ãƒˆ
> 
> ```dataviewjs
> const dbFolders = [
> "03.ãƒ„ã‚§ãƒƒãƒ†ãƒ«ã‚«ã‚¹ãƒ†ãƒ³/030.ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹/01.é£²é£Ÿãƒ»ã‚°ãƒ«ãƒ¡",
> "03.ãƒ„ã‚§ãƒƒãƒ†ãƒ«ã‚«ã‚¹ãƒ†ãƒ³/030.ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹/02.æ—…è¡Œãƒ»è¦³å…‰",
> "03.ãƒ„ã‚§ãƒƒãƒ†ãƒ«ã‚«ã‚¹ãƒ†ãƒ³/030.ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹/03.å­¦ç¿’ãƒ»æ•™è‚²",
> "03.ãƒ„ã‚§ãƒƒãƒ†ãƒ«ã‚«ã‚¹ãƒ†ãƒ³/030.ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹/04.ãƒ“ã‚¸ãƒã‚¹ãƒ»ä»•äº‹",
> "03.ãƒ„ã‚§ãƒƒãƒ†ãƒ«ã‚«ã‚¹ãƒ†ãƒ³/030.ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹/05.ã‚²ãƒ¼ãƒ ãƒ»ã‚¨ãƒ³ã‚¿ãƒ¼ãƒ†ã‚¤ãƒ¡ãƒ³ãƒˆ",
> "03.ãƒ„ã‚§ãƒƒãƒ†ãƒ«ã‚«ã‚¹ãƒ†ãƒ³/030.ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹/06.ç§‘å­¦ãƒ»æŠ€è¡“",
> "03.ãƒ„ã‚§ãƒƒãƒ†ãƒ«ã‚«ã‚¹ãƒ†ãƒ³/030.ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹/07.æ–‡åŒ–ãƒ»æ­´å²",
> "03.ãƒ„ã‚§ãƒƒãƒ†ãƒ«ã‚«ã‚¹ãƒ†ãƒ³/030.ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹/08.ç”Ÿæ´»ãƒ»ãƒ©ã‚¤ãƒ•ãƒãƒƒã‚¯",
> "03.ãƒ„ã‚§ãƒƒãƒ†ãƒ«ã‚«ã‚¹ãƒ†ãƒ³/030.ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹/09.ãƒ‹ãƒ¥ãƒ¼ã‚¹ãƒ»æ™‚äº‹",
> "03.ãƒ„ã‚§ãƒƒãƒ†ãƒ«ã‚«ã‚¹ãƒ†ãƒ³/030.ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹/10.èª­æ›¸ãƒ»æ›¸ç±"
> ];
> let allNotes = [];
> for (let folder of dbFolders) {
> const notes = dv.pages(`"${folder}"`).where(p => p.file.name !== "index" && p.file.name !== "README");
> allNotes = allNotes.concat(notes.array());
> }
> if (allNotes.length === 0) {
> dv.paragraph("_ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ãƒãƒ¼ãƒˆãŒã‚ã‚Šã¾ã›ã‚“_");
> } else {
> const today = moment().format("YYYY-MM-DD");
> const seed = today.split('').reduce((acc, c) => acc + c.charCodeAt(0), 0);
> const randomIndex = seed % allNotes.length;
> const randomNote = allNotes[randomIndex];
> const content = await dv.io.load(randomNote.file.path);
> let preview = content.substring(0, 200).trim();
> preview = preview.replace(/^#+\s+/gm, '').replace(/\[\[([^\]]+)\]\]/g, '$1').replace(/\n+/g, ' ');
> if (preview.length >= 200) preview += '...';
> const category = randomNote.file.folder.split('/').pop();
> dv.paragraph(`**${category}** ğŸ“‚`);
> dv.paragraph(`### ${randomNote.file.name}`);
> dv.paragraph(`${preview}`);
> dv.paragraph(`\nğŸ‘‰ [[${randomNote.file.path}|å…¨æ–‡ã‚’èª­ã‚€]]`);
> }
> ```

 

> [!info]- ğŸ“º ä»Šè¦‹ã¦ã„ã‚‹ãƒ‰ãƒ©ãƒãƒ»ã‚¢ãƒ‹ãƒ¡
> 
> ```dataviewjs
> try {
> const content = await dv.io.load("03.ãƒ„ã‚§ãƒƒãƒ†ãƒ«ã‚«ã‚¹ãƒ†ãƒ³/032.PERMANENT/05.05.ä»Šè¦‹ã¦ã„ã‚‹ãƒ‰ãƒ©ãƒãƒ»ã‚¢ãƒ‹ãƒ¡ãƒªã‚¹ãƒˆ.md");
> if (content && typeof content === 'string') {
> const dramaMatch = content.match(/### ãƒ‰ãƒ©ãƒ\n([\s\S]*?)(?=\n###|$)/);
> const animeMatch = content.match(/### ã‚¢ãƒ‹ãƒ¡\n([\s\S]*?)(?=\n###|$)/);
> const movieMatch = content.match(/### æ˜ ç”»\n([\s\S]*?)(?=\n###|$)/);
> const otherMatch = content.match(/### ä»–ã®ãƒ¡ãƒ‡ã‚£ã‚¢\n([\s\S]*?)(?=\n###|$)/);
> let hasContent = false;
> if (dramaMatch && dramaMatch[1] && dramaMatch[1].trim()) {
> dv.paragraph("**ğŸ“º ãƒ‰ãƒ©ãƒ**");
> dv.paragraph(dramaMatch[1].trim());
> hasContent = true;
> }
> if (animeMatch && animeMatch[1] && animeMatch[1].trim()) {
> dv.paragraph("**ğŸ¬ ã‚¢ãƒ‹ãƒ¡**");
> dv.paragraph(animeMatch[1].trim());
> hasContent = true;
> }
> if (movieMatch && movieMatch[1] && movieMatch[1].trim()) {
> dv.paragraph("**ğŸ¥ æ˜ ç”»**");
> dv.paragraph(movieMatch[1].trim());
> hasContent = true;
> }
> if (otherMatch && otherMatch[1] && otherMatch[1].trim()) {
> dv.paragraph("**ğŸ“± ä»–ã®ãƒ¡ãƒ‡ã‚£ã‚¢**");
> dv.paragraph(otherMatch[1].trim());
> hasContent = true;
> }
> if (!hasContent) {
> dv.paragraph("_è¦–è´ä¸­ã®ä½œå“ãŒã‚ã‚Šã¾ã›ã‚“_");
> }
> } else {
> dv.paragraph("_ãƒªã‚¹ãƒˆã‚’èª­ã¿è¾¼ã‚ã¾ã›ã‚“ã§ã—ãŸ_");
> }
> } catch (error) {
> dv.paragraph("_ã‚¨ãƒ©ãƒ¼: ãƒªã‚¹ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“_");
> }
> ```
ğŸ‘‰ [[03.ãƒ„ã‚§ãƒƒãƒ†ãƒ«ã‚«ã‚¹ãƒ†ãƒ³/032.PERMANENT/05.05.ä»Šè¦‹ã¦ã„ã‚‹ãƒ‰ãƒ©ãƒãƒ»ã‚¢ãƒ‹ãƒ¡ãƒªã‚¹ãƒˆ|ç·¨é›†]]


> [!info]- ğŸ“Š 11æœˆæ”¯å‡ºã®é€²æ—
> 
> ```dataviewjs
> try {
>   const expensePath = "03.ãƒ„ã‚§ãƒƒãƒ†ãƒ«ã‚«ã‚¹ãƒ†ãƒ³/030.ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹/æ”¯å‡ºç®¡ç†/2025å¹´11æœˆç¾çŠ¶ã¾ã¨ã‚_20251102.md";
>   const content = await dv.io.load(expensePath);
>   
>   // äºˆç®—è¨­å®š
>   const budgets = {
>     total: 300000,
>     "é£Ÿè²»ãƒ»å¤–é£Ÿ": 24000,
>     "ã‚¿ãƒã‚³ä»£": 15000,
>     "äº¤é€šè²»": 30000,
>     "å…‰ç†±è²»": 10000,
>     "åˆ†å‰²æ‰•ã„": 15000,
>     "è¶£å‘³ãƒ»å¨¯æ¥½": 10000,
>     "ãã®ä»–å˜ç™º": 5000
>   };
>   
>   // åˆè¨ˆé‡‘é¡ã‚’æŠ½å‡ºï¼ˆã€Œåˆè¨ˆã€è¡Œã‹ã‚‰ï¼‰
>   const totalMatch = content.match(/\|\s*\*\*åˆè¨ˆ\*\*\s*\|\s*\*\*Â¥([\d,]+)\*\*/);
>   const totalSpent = totalMatch ? parseInt(totalMatch[1].replace(/,/g, '')) : 0;
>   
>   // äºˆç®—æ®‹ã‚’è¨ˆç®—
>   const remaining = budgets.total - totalSpent;
>   const usageRate = (totalSpent / budgets.total) * 100;
>   
>   // é€²æ—ãƒãƒ¼ã‚’ç”Ÿæˆ
>   const barLength = 20;
>   const filled = Math.floor((usageRate / 100) * barLength);
>   const bar = 'â–ˆ'.repeat(filled) + 'â–‘'.repeat(barLength - filled);
>   
>   // çŠ¶æ…‹ã‚¢ã‚¤ã‚³ãƒ³
>   let statusIcon = 'ğŸŸ¢';
>   if (usageRate >= 100) statusIcon = 'ğŸ”´';
>   else if (usageRate >= 80) statusIcon = 'ğŸŸ¡';
>   
>   // ä»Šæ—¥ã®æ—¥ä»˜ã¨æœˆæœ«ã¾ã§ã®æ—¥æ•°ã‚’è¨ˆç®—
>   const today = moment();
>   const lastDay = moment(today).endOf('month');
>   const daysLeft = lastDay.diff(today, 'days') + 1;
>   const dailyAverage = daysLeft > 0 ? Math.floor(remaining / daysLeft) : 0;
>   
>   // ã€Œä¸»è¦ã‚«ãƒ†ã‚´ãƒªã®äºˆç®—å†…è¨³ã€ãƒ†ãƒ¼ãƒ–ãƒ«ã‹ã‚‰ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—
>   const categoryData = {};
>   // ãƒ†ãƒ¼ãƒ–ãƒ«è¡Œã‚’æŠ½å‡ºï¼ˆé”æˆç‡ã®å¾Œã«ã‚¢ã‚¤ã‚³ãƒ³ãŒæ¥ã‚‹ï¼‰
>   const budgetTableRegex = /\|\s*([^|]+?)\s*\|\s*Â¥([\d,]+)\s*\|\s*Â¥([\d,]+)\s*\|\s*Â¥([\d,]+|-)\s*\|\s*([\d.]+)%\s*(.*?)\s*\|/g;
>   let match;
>   while ((match = budgetTableRegex.exec(content)) !== null) {
>     let category = match[1].trim().replace(/\*\*/g, '').replace(/ï¼ˆå›ºå®šè²»ï¼‰/, '').trim();
>     const used = parseInt(match[2].replace(/,/g, ''));
>     const budget = parseInt(match[3].replace(/,/g, ''));
>     const rate = parseFloat(match[5]);
>     const iconStr = match[6].trim();
>     
>     // ã‚¢ã‚¤ã‚³ãƒ³ã‚’åˆ¤å®šï¼ˆæ–‡å­—åˆ—ã‹ã‚‰çµµæ–‡å­—ã‚’æ¤œå‡ºã€ã¾ãŸã¯é”æˆç‡ã‹ã‚‰åˆ¤å®šï¼‰
>     let icon = 'ğŸŸ¢';
>     if (iconStr.includes('ğŸŸ¢') || iconStr === 'ğŸŸ¢') {
>       icon = 'ğŸŸ¢';
>     } else if (iconStr.includes('ğŸŸ¡') || iconStr === 'ğŸŸ¡') {
>       icon = 'ğŸŸ¡';
>     } else if (iconStr.includes('ğŸ”´') || iconStr === 'ğŸ”´') {
>       icon = 'ğŸ”´';
>     } else {
>       // ã‚¢ã‚¤ã‚³ãƒ³ãŒæŠ½å‡ºã§ããªã„å ´åˆã¯é”æˆç‡ã‹ã‚‰åˆ¤å®š
>       if (rate >= 100) icon = 'ğŸ”´';
>       else if (rate >= 80) icon = 'ğŸŸ¡';
>       else icon = 'ğŸŸ¢';
>     }
>     
>     // ã‚«ãƒ†ã‚´ãƒªåã®æ­£è¦åŒ–
>     if (category === 'é£Ÿè²»ãƒ»å¤–é£Ÿ' || category.includes('é£Ÿè²»') || category.includes('å¤–é£Ÿ')) {
>       category = 'é£Ÿè²»ãƒ»å¤–é£Ÿ';
>     }
>     if (category === 'è¶£å‘³ãƒ»å¨¯æ¥½' || category.includes('toto')) {
>       category = 'è¶£å‘³ãƒ»å¨¯æ¥½';
>     }
>     if (category === 'ãã®ä»–å˜ç™º' || category === 'ãã®ä»–å¤‰å‹•è²»') {
>       category = 'ãã®ä»–å˜ç™º';
>     }
>     
>     if (budget > 0 && budgets[category]) {
>       categoryData[category] = { amount: used, budget, rate, icon };
>     }
>   }
>   
>   // è¡¨ç¤º
>   dv.paragraph(`**æœˆé–“ç·æ”¯å‡ºé€²æ—**        ${bar} ${usageRate.toFixed(1)}% (Â¥${totalSpent.toLocaleString()}/Â¥${budgets.total.toLocaleString()}) ${statusIcon}`);
>   dv.paragraph('');
>   dv.paragraph(`äºˆç®—æ®‹: Â¥${remaining.toLocaleString()} | ã‚ã¨${daysLeft}æ—¥ | 1æ—¥å¹³å‡ä½¿ç”¨å¯èƒ½é¡: Â¥${dailyAverage.toLocaleString()}`);
>   dv.paragraph('');
>   dv.paragraph('**ã‚«ãƒ†ã‚´ãƒªåˆ¥ä½¿ç”¨çŠ¶æ³**:');
>   
>   // ã‚«ãƒ†ã‚´ãƒªã‚’è¡¨ç¤ºé †ã«ä¸¦ã¹ã‚‹
>   const categoryOrder = ["é£Ÿè²»ãƒ»å¤–é£Ÿ", "ã‚¿ãƒã‚³ä»£", "äº¤é€šè²»", "å…‰ç†±è²»", "åˆ†å‰²æ‰•ã„", "è¶£å‘³ãƒ»å¨¯æ¥½", "ãã®ä»–å˜ç™º"];
>   const categoryRows = [];
>   
>   for (const cat of categoryOrder) {
>     if (categoryData[cat]) {
>       const { amount, budget, rate, icon } = categoryData[cat];
>       categoryRows.push([cat, `Â¥${amount.toLocaleString()} / Â¥${budget.toLocaleString()} (${rate.toFixed(1)}%) ${icon}`]);
>     } else if (budgets[cat]) {
>       // ãƒ‡ãƒ¼ã‚¿ãŒãªã„å ´åˆã¯0å††ã¨ã—ã¦è¡¨ç¤º
>       categoryRows.push([cat, `Â¥0 / Â¥${budgets[cat].toLocaleString()} (0%) ğŸŸ¢`]);
>     }
>   }
>   
>   if (categoryRows.length > 0) {
>     dv.table(["ã‚«ãƒ†ã‚´ãƒª", "ä½¿ç”¨çŠ¶æ³"], categoryRows);
>   }
>   
>   dv.paragraph('');
>   dv.paragraph(`ğŸ‘‰ [[${expensePath}|11æœˆã®è©³ç´°åˆ†æ]]`);
>   
> } catch (error) {
>   dv.paragraph('_æ”¯å‡ºãƒ‡ãƒ¼ã‚¿ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸ_');
>   dv.paragraph(`ğŸ‘‰ [[03.ãƒ„ã‚§ãƒƒãƒ†ãƒ«ã‚«ã‚¹ãƒ†ãƒ³/030.ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹/æ”¯å‡ºç®¡ç†/2025å¹´11æœˆç¾çŠ¶ã¾ã¨ã‚_20251102|11æœˆã®è©³ç´°åˆ†æ]]`);
> }
> ```

> [!info]- ğŸ—“ ä»Šé€±ã®å¹´é–“è¨ˆç”»ï¼ˆä»•äº‹ãƒ»ãƒ—ãƒ©ã‚¤ãƒ™ãƒ¼ãƒˆï¼‰
> 
> ```dataviewjs
> // é€±ç•ªå·ï¼ˆä¼šè¨ˆå¹´åº¦ 4/1 èµ·ç®—ï¼‰
> const today2 = moment();
> const currentYear2 = today2.year();
> const currentMonth2 = today2.month() + 1;
> const fyStart = (currentMonth2 >= 4) ? moment(`${currentYear2}-04-01`) : moment(`${currentYear2 - 1}-04-01`);
> const weekNum = Math.floor(today2.diff(fyStart, 'days') / 7) + 1;
> 
> const md = await dv.io.load(dv.current().file.path);
> 
> function sliceBetween(markdown, start, nextStarts){
>   const s = markdown.indexOf(start);
>   if (s === -1) return '';
>   const rest = markdown.slice(s);
>   let e = rest.length;
>   for (const n of nextStarts){
>     const i = rest.indexOf(n);
>     if (i !== -1 && i < e) e = i;
>   }
>   return rest.slice(0, e);
> }
> 
> const q3Block = sliceBetween(md, '### ğŸ“… 3Q', ['\n### ğŸ“… 4Q']);
> const q4Block = sliceBetween(md, '### ğŸ“… 4Q', ['\n## ', '\n### ğŸ“… 3Q']);
> const block = (weekNum >= 27 && weekNum <= 39) ? q3Block : q4Block;
> 
> function firstTableAfter(anchor){
>   const idx = block.indexOf(anchor);
>   if (idx === -1) return '';
>   const tail = block.slice(idx);
>   const m = tail.match(/\n\|[^\n]*\n[\s\S]*?(?=\n\n|\n[^|]|$)/);
>   return m ? m[0].trim() : '';
> }
> 
> const workTableMd = firstTableAfter('**ğŸ’¼ ä»•äº‹ç”¨');
> const privateTableMd = firstTableAfter('**ğŸ  ãƒ—ãƒ©ã‚¤ãƒ™ãƒ¼ãƒˆç”¨');
> 
> function parseTable(mdTable){
>   if (!mdTable) return [];
>   const rows = mdTable.split('\n').filter(l => l.trim().startsWith('|'));
>   return rows.map(r => r.split('|').slice(1, -1).map(c => c.replace(/<br\s*\/>?/gi, '\n').trim()));
> }
> 
> const work = parseTable(workTableMd);
> const priv = parseTable(privateTableMd);
> if (work.length === 0 || priv.length === 0){
>   dv.paragraph('_å¹´é–“è¨ˆç”»ãƒ†ãƒ¼ãƒ–ãƒ«ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“_');
> } else {
>   const headers = work[0];
>   const label = `ç¬¬${weekNum}é€±`;
>   const colIdx = headers.findIndex(h => h.includes(label));
>   if (colIdx === -1){
>     dv.paragraph(`_ç¬¬${weekNum}é€±ã®åˆ—ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“_`);
>   } else {
>     const get = (table, rowLabel) => {
>       for (let r = 2; r < table.length; r++){
>         if (table[r][0].replace(/\s/g,'') === rowLabel.replace(/\s/g,'')){
>           return (table[r][colIdx] || '').trim();
>         }
>       }
>       return '';
>     };
>     const norm = t => (t || '').replace(/\n+/g, ' / ').replace(/\s{2,}/g,' ').trim();
> 
>     dv.paragraph(`ğŸ—“ **ç¬¬${weekNum}é€±ã®äºˆå®š**`);
>     dv.paragraph('**ğŸ’¼ ä»•äº‹**');
>     const workItems = [
>       ['ğŸ¯ å•†å“', norm(get(work, 'ğŸ¯ å•†å“'))],
>       ['ğŸ’¼ ä»•äº‹', norm(get(work, 'ğŸ’¼ ä»•äº‹'))],
>       ['ğŸ“Š èª²é¡Œé€²æ—', norm(get(work, 'ğŸ“Š èª²é¡Œé€²æ—'))]
>     ];
>     let any = false;
>     for (const [label2, text] of workItems){ if (text){ dv.paragraph(`- ${label2}: ${text}`); any = true; } }
>     if (!any) dv.paragraph('- ãªã—');
> 
>     dv.paragraph('**ğŸ  ãƒ—ãƒ©ã‚¤ãƒ™ãƒ¼ãƒˆ**');
>     const privItems = [
>       ['ğŸ’° è²¯é‡‘', norm(get(priv, 'ğŸ’° è²¯é‡‘'))],
>       ['ğŸ“ note', norm(get(priv, 'ğŸ“ note'))],
>       ['ğŸ  ç”Ÿæ´»', norm(get(priv, 'ğŸ  ç”Ÿæ´»'))]
>     ];
>     any = false;
>     for (const [label3, text] of privItems){ if (text){ dv.paragraph(`- ${label3}: ${text}`); any = true; } }
>     if (!any) dv.paragraph('- ãªã—');
>   }
> }
> ```


> [!info]- ğŸ““ å¹´é–“è¨ˆç”»ï¼ˆç¾åœ¨ãƒ»æ¬¡ã®ã‚¯ã‚ªãƒ¼ã‚¿ãƒ¼ï¼‰
> 
> **ğŸ“… 3Qï¼ˆ10æœˆã€œ12æœˆï¼‰ç¬¬27é€±ã€œç¬¬39é€± - ç¾åœ¨ã®ã‚¯ã‚ªãƒ¼ã‚¿ãƒ¼**
> 
> **ğŸ’¼ ä»•äº‹ç”¨ï¼ˆå•†å“ãƒ»ä»•äº‹ãƒ»èª²é¡Œé€²æ—ï¼‰**
> 
> | ã‚«ãƒ†ã‚´ãƒªãƒ¼   | ç¬¬27é€±<br>9/29-10/5 | ç¬¬28é€±<br>10/6-10/12 | ç¬¬29é€±<br>10/13-10/19 | ç¬¬30é€±<br>10/20-10/26 | ç¬¬31é€±<br>10/27-11/2                                                                                   | ç¬¬32é€±<br>11/3-11/9                                                                                | ç¬¬33é€±<br>11/10-11/16 | ç¬¬34é€±<br>11/17-11/23 | ç¬¬35é€±<br>11/24-11/30 | ç¬¬36é€±<br>12/1-12/7 | ç¬¬37é€±<br>12/8-12/14        | ç¬¬38é€±<br>12/15-12/21 | ç¬¬39é€±<br>12/22-12/28 |
> | ------- | ----------------- | ------------------ | ------------------- | ------------------- | ---------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------ | ------------------- | ------------------- | ------------------- | ----------------- | ------------------------- | ------------------- | ------------------- |
> | ğŸ¯ å•†å“   |                   |                    | ãƒ»                   |                     | ãƒ»å®¶å…·å£²ä¸Šâ†’å€‹äººåˆ¥è¦‹ç©ã‚‚ã‚Šå–å¾—ç›®æ¨™<br><br>ã€æœ€é«˜16â„ƒæœ€ä½12â„ƒã€ã‚‚ã†æ¸©åº¦èª¿æ•´ã¯å£²ã‚Œãªã„ã€NWã°ã£ã‹ã‚Šæ›ãµã¨ã‚“å£²ã‚Œã‚‹ã€‚ã€‘<br><br>ã€ç„¡å°è‰¯å“é€±é–“ã¯é•·å²¡åº—ã§1000ä¸‡æœ€å¤§å˜æ—¥å¢—ãˆã‚‹ã£ã½ã„ã€‘ | ãƒ»æ›ãµã¨ã‚“è¦³åˆ†åˆ¤<br>ãƒ»Christmaså•†æã¯å£²å ´ã«å…¨ã¦å‡ºã—åˆ‡ã‚‹ã€‚<br><br>ãƒ»é€±è²©ãŒï¼ã®Christmaså•†æã‚’ï¼‘ç­‰åœ°äºŒç§»å‹•ã™ã‚‹ã€‚ã‚»ã‚ªãƒªãƒ¼çš„ã«ã¯å£²ã‚Œãªã„ã‚‚ã®ã‚’å‰ã«å‡ºã™ã®ã¯ãŠã‹ã—ã„ã‘ã© | ãƒ»Christmaså•†æã®å®Ÿç¸¾ç¢ºèª   |                     | ãƒ»Christmasãƒ”ãƒ¼ã‚¯<br>   |                   | ãƒ»é€±æœ«ChristmasBè²©<br>ãƒ»å…¥è·é‡ãƒ”ãƒ¼ã‚¯ |                     |                     |
> | ğŸ’¼ ä»•äº‹   |                   |                    |                     |                     | ã‚µãƒ³ãƒ—ãƒ«ç½®ãå ´æ•´ç†âœ”ï¸                                                                                          | ãƒ»ã»ã‚“ã¾ã«å®¶å…·å£²ã‚Œãªã„                                                                                      | åº—é•·ä¼šè­°                |                     | ãƒ»ï¼•ï¼‘æ‹¡ç¸®èµ·æ¡ˆ<br>ãƒ»å¥‘ç´„æ›´æ–°å®Œäº†  | å¾Œæ–¹ç¹å¿™æœŸå¯¾ç­–           |                           |                     |                     |
> | ğŸ“Š èª²é¡Œé€²æ— | ã€èª²é¡Œã¯WBSã‚’ä½œæˆã™ã‚‹ã€‘     |                    |                     |                     | è³‡æ–™ä½œæˆ<br>ãƒ¬ã‚®ãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³è¨­å®š                                                                                   | ã‚¨ãƒªã‚¢MTæ¡ˆå†…/å®Ÿé¨“é–‹å§‹                                                                                     | åŠ¹æœæ¤œè¨¼<br>            | ç¬¬äºŒã®çŸ¢                |                     |                   |                           |                     |                     |
> 
> **ğŸ  ãƒ—ãƒ©ã‚¤ãƒ™ãƒ¼ãƒˆç”¨ï¼ˆè²¯é‡‘ãƒ»noteãƒ»ç”Ÿæ´»ï¼‰**
> 
> | ã‚«ãƒ†ã‚´ãƒªãƒ¼   | ç¬¬27é€±<br>9/29-10/5 | ç¬¬28é€±<br>10/6-10/12 | ç¬¬29é€±<br>10/13-10/19 | ç¬¬30é€±<br>10/20-10/26 | ç¬¬31é€±<br>10/27-11/2 | ç¬¬32é€±<br>11/3-11/9              | ç¬¬33é€±<br>11/10-11/16 | ç¬¬34é€±<br>11/17-11/23 | ç¬¬35é€±<br>11/24-11/30  | ç¬¬36é€±<br>12/1-12/7 | ç¬¬37é€±<br>12/8-12/14 | ç¬¬38é€±<br>12/15-12/21 | ç¬¬39é€±<br>12/22-12/28 |
> | ------- | ----------------- | ------------------ | ------------------- | ------------------- | ------------------ | ------------------------------ | ------------------- | ------------------- | -------------------- | ----------------- | ------------------ | ------------------- | ------------------- |
> | ğŸ’° è²¯é‡‘   |                   |                    |                     |                     | ã€11æœˆæ”¯æ‰•ã„åˆ†ã¯èµ¤å­—ã€‘       |                                |                     |                     | åæ”¯ã‚’ãƒ—ãƒ©ã‚¹ã«ã™ã‚‹            |                   |                    |                     |                     |
> | ğŸ“ note |                   |                    |                     |                     |                    | ãƒã‚¦ãƒã‚¦è§£èª¬ã˜ã‚ƒãªãã¦æ€è€ƒã—ã¦æ›¸ããŸã„ã€‚æƒ…ç·’çš„ãªäº‹ã‚‚æ›¸ããŸã„ |                     |                     | 34è¨˜äº‹ä½œæˆ<br>1000viewç²å¾— | 36è¨˜äº‹ä½œæˆ            | 38è¨˜äº‹ä½œæˆ             | 40è¨˜äº‹ä½œæˆ              | 3000viewç²å¾—          |
> | ğŸ  ç”Ÿæ´»   |                   |                    |                     |                     |                    | é‡‘å³¯ç¥ç¤¾è¨ªå•                         |                     |                     |                      | é‡‘å³¯ç¥ç¤¾è¨ªå•            |                    |                     | é£Ÿæ´—æ©Ÿã®è³¼å…¥æ¤œè¨            |
> **ğŸ“… 4Qï¼ˆ1æœˆã€œ3æœˆï¼‰ç¬¬40é€±ã€œç¬¬52é€± - æ¬¡ã®ã‚¯ã‚ªãƒ¼ã‚¿ãƒ¼**
> 
> **ğŸ’¼ ä»•äº‹ç”¨ï¼ˆå•†å“ãƒ»ä»•äº‹ãƒ»èª²é¡Œé€²æ—ï¼‰**
> 
> | ã‚«ãƒ†ã‚´ãƒªãƒ¼   | ç¬¬40é€±<br>12/30-1/5               | ç¬¬41é€±<br>1/6-1/12 | ç¬¬42é€±<br>1/13-1/19 | ç¬¬43é€±<br>1/20-1/26 | ç¬¬44é€±<br>1/27-2/2 | ç¬¬45é€±<br>2/3-2/9 | ç¬¬46é€±<br>2/10-2/16 | ç¬¬47é€±<br>2/17-2/23 | ç¬¬48é€±<br>2/24-3/2 | ç¬¬49é€±<br>3/3-3/9 | ç¬¬50é€±<br>3/10-3/16 | ç¬¬51é€±<br>3/17-3/23 | ç¬¬52é€±<br>3/24-3/30 |
> | ------- | ------------------------------- | ---------------- | ----------------- | ----------------- | ---------------- | --------------- | ----------------- | ----------------- | ---------------- | --------------- | ----------------- | ----------------- | ----------------- |
> | ğŸ¯ å•†å“   |                                 |                  |                   |                   |                  |                 |                   |                   |                  |                 |                   |                   |                   |
> | ğŸ’¼ ä»•äº‹   | èª²é¡Œæ–¹å‘è³‡æ–™ä½œæˆ<br><br>æ¬¡æœŸKPIã®WBSã‚’ä½œæˆã™ã‚‹ã€‚ | ãƒ»                |                   |                   |                  |                 | ãƒ»ç¹å¿™æœŸå¯¾ç­–            |                   |                  |                 |                   |                   |                   |
> | ğŸ“Š èª²é¡Œé€²æ— |                                 |                  |                   |                   |                  |                 |                   |                   |                  |                 |                   |                   |                   |
> 
> **ğŸ  ãƒ—ãƒ©ã‚¤ãƒ™ãƒ¼ãƒˆç”¨ï¼ˆè²¯é‡‘ãƒ»noteãƒ»ç”Ÿæ´»ï¼‰**
> 
> | ã‚«ãƒ†ã‚´ãƒªãƒ¼   | ç¬¬40é€±<br>12/30-1/5 | ç¬¬41é€±<br>1/6-1/12 | ç¬¬42é€±<br>1/13-1/19 | ç¬¬43é€±<br>1/20-1/26 | ç¬¬44é€±<br>1/27-2/2 | ç¬¬45é€±<br>2/3-2/9 | ç¬¬46é€±<br>2/10-2/16 | ç¬¬47é€±<br>2/17-2/23 | ç¬¬48é€±<br>2/24-3/2 | ç¬¬49é€±<br>3/3-3/9 | ç¬¬50é€±<br>3/10-3/16 | ç¬¬51é€±<br>3/17-3/23 | ç¬¬52é€±<br>3/24-3/30 |
> | ------- | ----------------- | ---------------- | ----------------- | ----------------- | ---------------- | --------------- | ----------------- | ----------------- | ---------------- | --------------- | ----------------- | ----------------- | ----------------- |
> | ğŸ’° è²¯é‡‘   |                   |                  |                   |                   |                  |                 |                   |                   |                  |                 |                   |                   |                   |
> | ğŸ“ note |                   |                  |                   |                   |                  |                 |                   |                   |                  |                 |                   |                   |                   |
> | ğŸ  ç”Ÿæ´»   |                   |                  |                   | å©šç´„ã™ã‚‹              |                  |                 |                   |                   |                  |                 |                   |                   |                   |

> [!info]- ğŸŒŸ 30å¹´è¨ˆç”»ï¼ˆãƒ—ãƒ©ã‚¤ãƒ™ãƒ¼ãƒˆï¼‰
> 
> 
> > [!info]- ğŸ“… 2025-2034å¹´ï¼ˆ10å¹´è¨ˆç”» - ç¬¬1æœŸï¼‰
> > 
> > | ã‚«ãƒ†ã‚´ãƒªãƒ¼   | 2025å¹´<br>29æ­³         | 2026å¹´<br>30æ­³         | 2027å¹´<br>31æ­³          | 2028å¹´<br>32æ­³          | 2029å¹´<br>33æ­³      | 2030å¹´<br>34æ­³      | 2031å¹´<br>35æ­³      | 2032å¹´<br>36æ­³      | 2033å¹´<br>37æ­³      | 2034å¹´<br>38æ­³      |
> > | ------- | -------------------- | -------------------- | --------------------- | --------------------- | ----------------- | ----------------- | ----------------- | ----------------- | ----------------- | ----------------- |
> > | ğŸ’° è²¯é‡‘   | ãƒ‰ãƒ«å»ºã¦ï¼š48ä¸‡å††<br>è²¯é‡‘ï¼š133ä¸‡ | ãƒ‰ãƒ«å»ºã¦ï¼š96ä¸‡å††<br>è²¯é‡‘ï¼š200ä¸‡ | ãƒ‰ãƒ«å»ºã¦ï¼š144ä¸‡å††<br>è²¯é‡‘ï¼š500ä¸‡ | ãƒ‰ãƒ«å»ºã¦ï¼š192ä¸‡å††<br>è²¯é‡‘ï¼š700ä¸‡ | ãƒ‰ãƒ«å»ºã¦ï¼š240ä¸‡å††<br>è²¯é‡‘ï¼š | ãƒ‰ãƒ«å»ºã¦ï¼š288ä¸‡å††<br>è²¯é‡‘ï¼š | ãƒ‰ãƒ«å»ºã¦ï¼š336ä¸‡å††<br>è²¯é‡‘ï¼š | ãƒ‰ãƒ«å»ºã¦ï¼š384ä¸‡å††<br>è²¯é‡‘ï¼š | ãƒ‰ãƒ«å»ºã¦ï¼š432ä¸‡å††<br>è²¯é‡‘ï¼š | ãƒ‰ãƒ«å»ºã¦ï¼š480ä¸‡å††<br>è²¯é‡‘ï¼š |
> > | ğŸ“ note |                      |                      |                       |                       |                   |                   |                   |                   |                   |                   |
> > | ğŸ  ç”Ÿæ´»   |                      | å©šç´„                   | çµå©š                    |                       |                   | å­ä¾›                |                   |                   |                   |                   |
> 
> 
> > [!info]- ğŸ“… 2035-2044å¹´ï¼ˆ10å¹´è¨ˆç”» - ç¬¬2æœŸï¼‰
> > 
> > | ã‚«ãƒ†ã‚´ãƒªãƒ¼   | 2035å¹´<br>39æ­³      | 2036å¹´<br>40æ­³      | 2037å¹´<br>41æ­³      | 2038å¹´<br>42æ­³      | 2039å¹´<br>43æ­³      | 2040å¹´<br>44æ­³      | 2041å¹´<br>45æ­³      | 2042å¹´<br>46æ­³      | 2043å¹´<br>47æ­³      | 2044å¹´<br>48æ­³      |
> > | ------- | ----------------- | ----------------- | ----------------- | ----------------- | ----------------- | ----------------- | ----------------- | ----------------- | ----------------- | ----------------- |
> > | ğŸ’° è²¯é‡‘   | ãƒ‰ãƒ«å»ºã¦ï¼š528ä¸‡å††<br>è²¯é‡‘ï¼š | ãƒ‰ãƒ«å»ºã¦ï¼š576ä¸‡å††<br>è²¯é‡‘ï¼š | ãƒ‰ãƒ«å»ºã¦ï¼š624ä¸‡å††<br>è²¯é‡‘ï¼š | ãƒ‰ãƒ«å»ºã¦ï¼š672ä¸‡å††<br>è²¯é‡‘ï¼š | ãƒ‰ãƒ«å»ºã¦ï¼š720ä¸‡å††<br>è²¯é‡‘ï¼š | ãƒ‰ãƒ«å»ºã¦ï¼š768ä¸‡å††<br>è²¯é‡‘ï¼š | ãƒ‰ãƒ«å»ºã¦ï¼š816ä¸‡å††<br>è²¯é‡‘ï¼š | ãƒ‰ãƒ«å»ºã¦ï¼š864ä¸‡å††<br>è²¯é‡‘ï¼š | ãƒ‰ãƒ«å»ºã¦ï¼š912ä¸‡å††<br>è²¯é‡‘ï¼š | ãƒ‰ãƒ«å»ºã¦ï¼š960ä¸‡å††<br>è²¯é‡‘ï¼š |
> > | ğŸ“ note |                   |                   |                   |                   |                   |                   |                   |                   |                   |                   |
> > | ğŸ  ç”Ÿæ´»   |                   |                   |                   |                   |                   | å­ä¾›10æ­³             |                   |                   |                   |                   |
> 
> 
> 
> 
> > [!info]- ğŸ“… 2045-2054å¹´ï¼ˆ10å¹´è¨ˆç”» - ç¬¬3æœŸï¼‰
> > 
> > | ã‚«ãƒ†ã‚´ãƒªãƒ¼   | 2045å¹´<br>49æ­³        | 2046å¹´<br>50æ­³        | 2047å¹´<br>51æ­³        | 2048å¹´<br>52æ­³        | 2049å¹´<br>53æ­³        | 2050å¹´<br>54æ­³        | 2051å¹´<br>55æ­³        | 2052å¹´<br>56æ­³        | 2053å¹´<br>57æ­³        | 2054å¹´<br>58æ­³        |
> > | ------- | ------------------- | ------------------- | ------------------- | ------------------- | ------------------- | ------------------- | ------------------- | ------------------- | ------------------- | ------------------- |
> > | ğŸ’° è²¯é‡‘   | ãƒ‰ãƒ«å»ºã¦ï¼š1,008ä¸‡å††<br>è²¯é‡‘ï¼š | ãƒ‰ãƒ«å»ºã¦ï¼š1,056ä¸‡å††<br>è²¯é‡‘ï¼š | ãƒ‰ãƒ«å»ºã¦ï¼š1,104ä¸‡å††<br>è²¯é‡‘ï¼š | ãƒ‰ãƒ«å»ºã¦ï¼š1,152ä¸‡å††<br>è²¯é‡‘ï¼š | ãƒ‰ãƒ«å»ºã¦ï¼š1,200ä¸‡å††<br>è²¯é‡‘ï¼š | ãƒ‰ãƒ«å»ºã¦ï¼š1,248ä¸‡å††<br>è²¯é‡‘ï¼š | ãƒ‰ãƒ«å»ºã¦ï¼š1,296ä¸‡å††<br>è²¯é‡‘ï¼š | ãƒ‰ãƒ«å»ºã¦ï¼š1,344ä¸‡å††<br>è²¯é‡‘ï¼š | ãƒ‰ãƒ«å»ºã¦ï¼š1,392ä¸‡å††<br>è²¯é‡‘ï¼š | ãƒ‰ãƒ«å»ºã¦ï¼š1,440ä¸‡å††<br>è²¯é‡‘ï¼š |
> > | ğŸ“ note |                     |                     |                     |                     |                     |                     |                     |                     |                     |                     |
> > | ğŸ  ç”Ÿæ´»   |                     | ãƒœã‚±ã¦ã‚‚ã†ã–ããªã„ã‚¸ã‚¸ã‚¤ã‚’ç›®æŒ‡ã™ã€‚   |                     |                     |                     | å­ä¾›æˆäºº                |                     |                     |                     |                     |
> 
> 
> 
> 
> > [!info]- ğŸ“… 2055-2064å¹´ï¼ˆ10å¹´è¨ˆç”» - ç¬¬4æœŸï¼‰
> > 
> > | ã‚«ãƒ†ã‚´ãƒªãƒ¼   | 2055å¹´<br>59æ­³        | 2056å¹´<br>60æ­³        | 2057å¹´<br>61æ­³        | 2058å¹´<br>62æ­³        | 2059å¹´<br>63æ­³        | 2060å¹´<br>64æ­³        | 2061å¹´<br>65æ­³        | 2062å¹´<br>66æ­³        | 2063å¹´<br>67æ­³        | 2064å¹´<br>68æ­³        |
> > | ------- | ------------------- | ------------------- | ------------------- | ------------------- | ------------------- | ------------------- | ------------------- | ------------------- | ------------------- | ------------------- |
> > | ğŸ’° è²¯é‡‘   | ãƒ‰ãƒ«å»ºã¦ï¼š1,488ä¸‡å††<br>è²¯é‡‘ï¼š | ãƒ‰ãƒ«å»ºã¦ï¼š1,536ä¸‡å††<br>è²¯é‡‘ï¼š | ãƒ‰ãƒ«å»ºã¦ï¼š1,584ä¸‡å††<br>è²¯é‡‘ï¼š | ãƒ‰ãƒ«å»ºã¦ï¼š1,632ä¸‡å††<br>è²¯é‡‘ï¼š | ãƒ‰ãƒ«å»ºã¦ï¼š1,680ä¸‡å††<br>è²¯é‡‘ï¼š | ãƒ‰ãƒ«å»ºã¦ï¼š1,728ä¸‡å††<br>è²¯é‡‘ï¼š | ãƒ‰ãƒ«å»ºã¦ï¼š1,776ä¸‡å††<br>è²¯é‡‘ï¼š | ãƒ‰ãƒ«å»ºã¦ï¼š1,824ä¸‡å††<br>è²¯é‡‘ï¼š | ãƒ‰ãƒ«å»ºã¦ï¼š1,872ä¸‡å††<br>è²¯é‡‘ï¼š | ãƒ‰ãƒ«å»ºã¦ï¼š1,920ä¸‡å††<br>è²¯é‡‘ï¼š |
> > | ğŸ“ note |                     |                     |                     |                     |                     |                     |                     |                     |                     |                     |
> > | ğŸ  ç”Ÿæ´»   |                     |                     |                     |                     |                     | å®šå¹´                  |                     |                     |                     |                     |
> 
> 
> 
> 
> > [!info]- ğŸ“… 2065-2074å¹´ï¼ˆ10å¹´è¨ˆç”» - ç¬¬5æœŸï¼‰
> > 
> > | ã‚«ãƒ†ã‚´ãƒªãƒ¼   | 2065å¹´<br>69æ­³        | 2066å¹´<br>70æ­³ | 2067å¹´<br>71æ­³ | 2068å¹´<br>72æ­³ | 2069å¹´<br>73æ­³ | 2070å¹´<br>74æ­³ | 2071å¹´<br>75æ­³ | 2072å¹´<br>76æ­³ | 2073å¹´<br>77æ­³ | 2074å¹´<br>78æ­³ |
> > | ------- | ------------------- | ------------ | ------------ | ------------ | ------------ | ------------ | ------------ | ------------ | ------------ | ------------ |
> > | ğŸ’° è²¯é‡‘   | ãƒ‰ãƒ«å»ºã¦ï¼š1,968ä¸‡å††<br>è²¯é‡‘ï¼š | è²¯é‡‘ï¼š          | è²¯é‡‘ï¼š          | è²¯é‡‘ï¼š          | è²¯é‡‘ï¼š          | è²¯é‡‘ï¼š          | è²¯é‡‘ï¼š          | è²¯é‡‘ï¼š          | è²¯é‡‘ï¼š          | è²¯é‡‘ï¼š          |
> > | ğŸ“ note |                     |              |              |              |              |              |              |              |              |              |
> > | ğŸ  ç”Ÿæ´»   |                     | ãƒ‰ãƒ«å»ºã¦å—å–é–‹å§‹     |              |              |              |              |              |              |              |              |
> 
> 
> 
> 
> > [!info]- ğŸ“… 2075-2084å¹´ï¼ˆ10å¹´è¨ˆç”» - ç¬¬6æœŸï¼‰
> > 
> > | ã‚«ãƒ†ã‚´ãƒªãƒ¼   | 2075å¹´<br>79æ­³ | 2076å¹´<br>80æ­³ | 2077å¹´<br>81æ­³ | 2078å¹´<br>82æ­³ | 2079å¹´<br>83æ­³ | 2080å¹´<br>84æ­³ | 2081å¹´<br>85æ­³ | 2082å¹´<br>86æ­³ | 2083å¹´<br>87æ­³ | 2084å¹´<br>88æ­³ |
> > | ------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
> > | ğŸ’° è²¯é‡‘   | è²¯é‡‘ï¼š | è²¯é‡‘ï¼š | è²¯é‡‘ï¼š | è²¯é‡‘ï¼š | è²¯é‡‘ï¼š | è²¯é‡‘ï¼š | è²¯é‡‘ï¼š | è²¯é‡‘ï¼š | è²¯é‡‘ï¼š | è²¯é‡‘ï¼š |
> > | ğŸ“ note |      |      |      |      |      |      |      |      |      |      |
> > | ğŸ  ç”Ÿæ´»   |      |      |      |      |      |      |      |      |      |      |
> 
> 
> 
> 
> > [!info]- ğŸ“… 2085-2086å¹´ï¼ˆæœ€çµ‚æœŸï¼‰
> > 
> > | ã‚«ãƒ†ã‚´ãƒªãƒ¼   | 2085å¹´<br>89æ­³ | 2086å¹´<br>90æ­³ |
> > | ------- | ---- | ---- |
> > | ğŸ’° è²¯é‡‘   | è²¯é‡‘ï¼š | è²¯é‡‘ï¼š |
> > | ğŸ“ note |      |      |
> > | ğŸ  ç”Ÿæ´»   |      | æ­»ã«ã¾ã™ã€‚ |
> 
> > 
> 
> 
